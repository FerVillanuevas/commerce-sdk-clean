{"version":3,"sources":["../src/clientConfig.ts","../src/helpers/environment.ts","../src/responseError.ts","../src/helpers/fetchHelper.ts","../src/templateUrl.ts","../src/version.ts","../src/shopperLogin.ts"],"sourcesContent":["/*\n * Copyright (c) 2021, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\nimport type { BaseUriParameters } from './helpers/types';\n\n/**\n * Alias for `RequestInit` from TypeScript's DOM lib, to more clearly differentiate\n * it from the `RequestInit` provided by node-fetch.\n */\ntype BrowserRequestInit = RequestInit;\n/**\n * Any properties supported in either the browser or node are accepted.\n * Using the right properties in the right context is left to the user.\n */\nexport type FetchOptions =  BrowserRequestInit;\n\n/**\n * Base options that can be passed to the `ClientConfig` class.\n */\nexport interface ClientConfigInit<Params extends BaseUriParameters> {\n  baseUri?: string;\n  proxy?: string;\n  headers?: {[key: string]: string};\n  parameters: Params;\n  fetchOptions?: FetchOptions;\n  transformRequest?: (\n    data: unknown,\n    headers: {[key: string]: string}\n  ) => Required<FetchOptions>['body'];\n  throwOnBadResponse?: boolean;\n}\n\nexport type FetchFunction = (\n  input: RequestInfo,\n  init?: FetchOptions | undefined\n) => Promise<Response>;\n\n/**\n * Configuration parameters common to Commerce SDK clients\n */\nexport default class ClientConfig<Params extends BaseUriParameters>\n  implements ClientConfigInit<Params>\n{\n  public baseUri?: string;\n\n  public proxy?: string;\n\n  public headers: {[key: string]: string};\n\n  public parameters: Params;\n\n  public fetchOptions: FetchOptions;\n\n  public transformRequest: NonNullable<\n    ClientConfigInit<Params>['transformRequest']\n  >;\n\n  public throwOnBadResponse: boolean;\n\n  constructor(config: ClientConfigInit<Params>) {\n    this.headers = {...config.headers};\n    this.parameters = {...config.parameters};\n    // shortCode is required in the type, but we still check that it is present for the JS users\n    if (!this.parameters.shortCode) {\n      throw new Error('Missing required parameter: shortCode');\n    }\n    this.fetchOptions = {\n      credentials: 'omit',\n      ...config.fetchOptions,\n    };\n    this.transformRequest =\n      config.transformRequest || ClientConfig.defaults.transformRequest;\n\n    // Optional properties\n    if (config.baseUri) {\n      this.baseUri = config.baseUri;\n    }\n    if (config.proxy) {\n      this.proxy = config.proxy;\n    }\n    this.throwOnBadResponse = !!config.throwOnBadResponse;\n  }\n\n  static readonly defaults: Pick<\n    Required<ClientConfigInit<never>>,\n    'transformRequest'\n  > = {\n    /**\n     * If the `Content-Type` header is `application/json`, the data is converted to a JSON string.\n     * If the `Content-Type` header is `application/x-www-form-urlencoded`, the data is converted to\n     * a `URLSearchParams` object.\n     * In all other cases, the data is returned unmodified.\n     * @param data - Data to transform\n     * @returns A payload appropriate for the specified `Content-Type` header\n     */\n    transformRequest(data, headers) {\n      switch (headers['Content-Type']) {\n        case 'application/json': {\n          return JSON.stringify(data);\n        }\n        case 'application/x-www-form-urlencoded': {\n          // Only SLAS uses this content type, and all of their payloads are Record<string, string>.\n          // Future APIs are unlikely to use this content type. Additionally, URLSearchParams\n          // actually accepts Record<string, unknown> and converts the values to strings.\n          // Therefore, this type assertion isn't *strictly* safe, but is unlikely to cause issues.\n          return new URLSearchParams(data as Record<string, string>);\n        }\n        default: {\n          // This type assertion isn't safe. However, this default case will not occur with the\n          // currently known APIs, as they all use a Content-Type already specified. Rather than\n          // throwing in this case, we return the data unmodified, to be more flexible in case there\n          // are different content types in future APIs.\n          return data as Required<FetchOptions>['body'];\n        }\n      }\n    },\n  };\n}\n","/*\n * Copyright (c) 2023, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\nimport type { FetchFunction } from \"../clientConfig\";\n\n/*\n * Copyright (c) 2022, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\nexport const isBrowser =\n  typeof window === \"object\" && typeof window.document === \"object\";\n\nexport const globalObject = isBrowser ? window : globalThis;\n\nexport const hasFetchAvailable = typeof globalObject.fetch === \"function\";\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\nexport const fetch: FetchFunction = (() => {\n  return globalObject.fetch;\n})();\n","/*\n * Copyright (c) 2022, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * Extends the Error class with the the error being a combination of status code\n * and text retrieved from the response.\n *\n * @class ResponseError\n * @extends Error\n */\nexport default class ResponseError extends Error {\n  constructor(public response: Response) {\n    super(`${response.status} ${response.statusText}`);\n  }\n}\n","/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\nimport { BaseUriParameters } from '.';\nimport type { FetchOptions } from '../clientConfig';\nimport { ClientConfigInit } from '../clientConfig';\nimport ResponseError from '../responseError';\nimport { fetch } from './environment';\n\n/**\n * A wrapper function around fetch designed for making requests using the SDK\n * @param url - The url of the resource that you wish to fetch\n * @param options? - An object containing any custom settings you want to apply to the request\n * @param options.method? - The request HTTP operation. 'GET' is the default if no method is provided.\n * @param options.headers? - Headers that are added to the request. Authorization header should be in this argument or in the clientConfig.headers\n * @param options.body? - Body that is used for the request\n * @param clientConfig? - Client Configuration object used by the SDK with properties that can affect the fetch call\n * @param clientConfig.headers? - Additional headers that are added to the request. Authorization header should be in this argument or in the options?.headers. options?.headers will override any duplicate properties.\n * @param clientConfig.fetchOptions? - fetchOptions that are passed onto the fetch request\n * @param clientConfig.throwOnBadResponse? - flag that when set true will throw a response error if the fetch request fails\n * @param rawResponse? - Flag to return the raw response from the fetch call. True for raw response object, false for the data from the response\n * @returns Raw response or data from response based on rawResponse argument from fetch call\n */\n// eslint-disable-next-line import/prefer-default-export\nexport const doFetch = async <Params extends BaseUriParameters>(\n  url: string,\n  options?: {\n    method?: string;\n    headers?: {\n      authorization?: string;\n    } & {[key: string]: string};\n    body?: BodyInit | globalThis.BodyInit | unknown;\n  },\n  clientConfig?: ClientConfigInit<Params>,\n  rawResponse?: boolean\n): Promise<Response | unknown> => {\n  const headers: Record<string, string> = {\n    ...clientConfig?.headers,\n    ...options?.headers,\n  };\n\n  const requestOptions: FetchOptions = {\n    ...clientConfig?.fetchOptions,\n    headers,\n    body: options?.body as\n      | (BodyInit & (globalThis.BodyInit | null))\n      | undefined,\n    method: options?.method ?? 'GET',\n  };\n\n  const response = await fetch(url, requestOptions);\n  if (rawResponse) {\n    return response;\n  }\n  if (\n    clientConfig?.throwOnBadResponse &&\n    !response.ok &&\n    response.status !== 304\n  ) {\n    throw new ResponseError(response);\n  } else {\n    const text = await response.text();\n    // It's ideal to get \"{}\" for an empty response body, but we won't throw if it's truly empty\n    return (text ? JSON.parse(text) : {}) as unknown | Response;\n  }\n};\n","/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\nimport type {PathParameters, QueryParameters} from './helpers/types';\n\nexport default class TemplateURL extends URL {\n  /**\n   * @param url -\n   * @param base -\n   */\n  constructor(\n    url: string,\n    base: string,\n    parameters?: {\n      pathParams?: PathParameters;\n      queryParams?: QueryParameters;\n      origin?: string;\n    }\n  ) {\n    super(\n      TemplateURL.renderTemplateUri(\n        `${base}/${url}`.replace(/\\/\\/+/g, '/'),\n        parameters?.pathParams\n      )\n    );\n    this.addQueryParams(parameters?.queryParams);\n    if (parameters?.origin) {\n      this.replaceOrigin(parameters?.origin);\n    }\n  }\n\n  /**\n   * Replace the origin (protocol/host) portion of the URL with a new origin.\n   * The path portion is retained and concatenated with any path included in the\n   * new origin. Thee primary use of this function is to use a proxy.\n   *\n   * @param newOriginString - The new origin to substitute (ex: https://example.com)\n   */\n  replaceOrigin(newOriginString: string): void {\n    const newOriginUrl = new URL(newOriginString);\n    this.protocol = newOriginUrl.protocol;\n    this.host = newOriginUrl.host;\n    this.pathname = `${newOriginUrl.pathname}/${this.pathname}`.replace(\n      /\\/\\/+/g,\n      '/'\n    );\n  }\n\n  /**\n   * Add append an object literal of query parameters to the URL object. SCAPI expects\n   * Arrays to be comma separated where \\{ a: [\"1\", \"2\"] \\} becomes ?a=1,2.\n   * The 'refine' query parameter is an exception, where SCAPI expects the the \"repeat\"\n   * convention where \\{ refine: [\"1\", \"2\"] \\} becomes \"?refine=1&refine=2\"\n   */\n  addQueryParams(queryParams?: QueryParameters): void {\n    if (queryParams) {\n      Object.keys(queryParams).forEach(key => {\n        const param = queryParams[key];\n        if (Array.isArray(param)) {\n          if (key === 'refine') {\n            for (let i = 0; i < param.length; i += 1) {\n              this.searchParams.append(key, String(param[i]));\n            }\n          } else {\n            this.searchParams.append(key, param.join());\n          }\n        } else {\n          this.searchParams.append(key, String(param));\n        }\n      });\n    }\n  }\n\n  /**\n   * Replace bracketed URL template parameters with values from parameters object\n   *\n   * @param template - The URL template string to make substitutions in\n   * @param parameters - The object literal that provides the values to substitute\n   *\n   * @returns String URL with substitutions made\n   */\n  static renderTemplateUri(\n    template: string,\n    parameters?: PathParameters\n  ): string {\n    return parameters\n      ? template.replace(\n          /\\{([^\\}]+)\\}/g /* eslint-disable-line no-useless-escape */,\n          (match, param: string) => String(parameters[param])\n        )\n      : template;\n  }\n}\n","export const USER_AGENT_HEADER = \"user-agent\";\nexport const USER_AGENT_VALUE = \"commerce-sdk-isomorphic@3.1.1\";\n","import ClientConfig, { ClientConfigInit } from \"./clientConfig\";\n// Must not import from ./helpers/index to avoid circular dependency via ShopperLogin\nimport { isBrowser } from \"./helpers/environment\";\nimport { doFetch } from \"./helpers/fetchHelper\";\nimport type {\n  BaseUriParameters,\n  CompositeParameters,\n  RequireParametersUnlessAllAreOptional\n} from \"./helpers/types\";\nimport TemplateURL from \"./templateUrl\";\nimport { USER_AGENT_HEADER, USER_AGENT_VALUE } from \"./version\";\n\nexport type LoginRequest = {\n  client_id?: string;\n  response_type?: string;\n  redirect_uri: string;\n  state?: string;\n  scope?: string;\n  usid?: string;\n  channel_id: string;\n  code_challenge?: string;\n} & { [key: string]: any }\n\n  export type TrustedAgentTokenRequest = {\n  agent_id?: string;\n  client_id: string;\n  channel_id: string;\n  code_verifier: string;\n  grant_type: string;\n  login_id: string;\n  idp_origin: string;\n  usid?: string;\n  dnt?: string;\n} & { [key: string]: any }\n\n  export type IntrospectResponse = {\n  active: boolean;\n  scope: string;\n  client_id: string;\n  sub: string;\n  exp: number;\n  username: string;\n  token_type: string;\n} & { [key: string]: any }\n\n  export type PasswordlessLoginRequest = {\n  user_id: string;\n  mode: string;\n  locale?: string;\n  usid?: string;\n  channel_id: string;\n  callback_uri?: string;\n} & { [key: string]: any }\n\n  export type PasswordLessLoginTokenRequest = {\n  grant_type: string;\n  hint: string;\n  pwdless_login_token: string;\n  client_id?: string;\n  code_verifier?: string;\n} & { [key: string]: any }\n\n  export type Oauth2ErrorResponse = {\n  error: string;\n  error_uri?: string;\n  error_description?: string;\n} & { [key: string]: any }\n\n  export type PasswordActionVerifyRequest = {\n  client_id: string;\n  pwd_action_token: string;\n  code_verifier: string;\n  new_password: string;\n  channel_id: string;\n} & { [key: string]: any }\n\n  export type TrustedSystemTokenRequest = {\n  usid?: string;\n  grant_type: string;\n  hint: string;\n  login_id: string;\n  idp_origin: string;\n  client_id: string;\n  channel_id: string;\n  email_id?: string;\n  dnt?: string;\n} & { [key: string]: any }\n\n  export type PasswordActionRequest = {\n  user_id: string;\n  mode: string;\n  channel_id: string;\n  locale?: string;\n  client_id?: string;\n  code_challenge?: string;\n  callback_uri?: string;\n  idp_name?: string;\n} & { [key: string]: any }\n\n  export type TokenResponse = {\n  access_token: string;\n  id_token: string;\n  refresh_token: string;\n  expires_in: number;\n  refresh_token_expires_in: any;\n  token_type: string;\n  usid: string;\n  customer_id: string;\n  enc_user_id: string;\n  idp_access_token: string;\n} & { [key: string]: any }\n\n  export type TokenRequest = {\n  refresh_token?: string;\n  code?: string;\n  usid?: string;\n  grant_type: string;\n  redirect_uri?: string;\n  code_verifier?: string;\n  client_id?: string;\n  channel_id?: string;\n  dnt?: string;\n} & { [key: string]: any }\n\n  export type TokenActionRequest = {\n  token: string;\n  token_type_hint?: string;\n} & { [key: string]: any }\n\n  export type SessionBridgeTokenRequest = {\n  code: string;\n  client_id: string;\n  channel_id: string;\n  code_verifier: string;\n  dwsid: string;\n  grant_type: string;\n  login_id: string;\n  dwsgst?: string;\n  usid?: string;\n  dnt?: string;\n} & { [key: string]: any }\n\n  type SlasRateLimit = { [key: string]: any }\nexport type ErrorResponse = {\n  type: string;\n  title?: string;\n  detail?: string;\n  instance?: string;\n} & { [key: string]: any }\n\n  export type ChangeControlled = {\n  creationDate?: any;\n  modificationDate?: any;\n  createdBy?: string;\n  lastModifiedBy?: string;\n} & { [key: string]: any }\n\n  type DateRangeFilter = { [key: string]: any }\ntype EtagResponse = { [key: string]: any }\ntype IntegerRangeFilter = { [key: string]: any }\ntype RateLimited3 = { [key: string]: any }\ntype SyncCreated = { [key: string]: any }\ntype DateConditionalRequest = { [key: string]: any }\ntype RateLimited5 = { [key: string]: any }\ntype EtagConditionalRequest = { [key: string]: any }\ntype AsyncCreated = { [key: string]: any }\ntype RateLimited = { [key: string]: any }\ntype RateLimited2 = { [key: string]: any }\ntype OffsetPaginated = { [key: string]: any }\ntype RangeFilter = { [key: string]: any }\ntype RateLimited4 = { [key: string]: any }\ntype NumericRangeFilter = { [key: string]: any }\ntype DatetimeRangeFilter = { [key: string]: any }\nexport type ChangeControlledDataType = {\n  creationDate?: any;\n  modificationDate?: any;\n  createdBy?: string;\n  lastModifiedBy?: string;\n} & { [key: string]: any }\n\n  export type Error = {\n  type: string;\n  title?: string;\n  detail?: string;\n  instance?: string;\n} & { [key: string]: any }\n\n  export type Money = {\n  currencyMnemonic?: string;\n  value?: number;\n} & { [key: string]: any }\n\n  export type SimpleSearchResult = {\n  limit: number;\n  hits?: Array<object>;\n  offset: any;\n  total: any;\n} & { [key: string]: any }\n\n  export type SearchRequest = {\n  limit?: number;\n  query: Query;\n  sorts?: Array<Sort>;\n  offset?: any;\n} & { [key: string]: any }\n\n  export type PropertyDefinition = {\n  defaultValue?: PropertyValueDefinition;\n  id?: string;\n  name: L10nString;\n  description: L10nString;\n  key?: boolean;\n  localizable?: boolean;\n  mandatory?: boolean;\n  max?: number;\n  minLength?: number;\n  min?: number;\n  multiValueType?: boolean;\n  regularExpression?: string;\n  scale?: number;\n  searchable?: boolean;\n  siteSpecific?: boolean;\n  system?: boolean;\n  unit?: L10nString;\n  possibleValues?: Array<PropertyValueDefinition>;\n  type: string;\n  visible?: boolean;\n} & { [key: string]: any }\n\n  export type LocalizedString = {\n} & { [key: string]: any }\n\n  export type PaginatedSearchResult = {\n  query: Query;\n  sorts?: Array<Sort>;\n  limit: number;\n  hits?: Array<object>;\n  offset: any;\n  total: any;\n} & { [key: string]: any }\n\n  export type ClosedObject = {\n} & { [key: string]: any }\n\n  export type OpenObject = {\n} & { [key: string]: any }\n\n  type QueryParamsLimit = { [key: string]: any }\ntype QueryParamsOffset = { [key: string]: any }\ntype SiteSpecific = { [key: string]: any }\nexport type NoPropertiesAllowed = {\n}\n  export type SpecifiedPropertiesAllowed = {\n} & { [key: string]: any }\n\n  export type BoolFilter = {\n  filters?: Array<Filter>;\n  operator: string;\n} & { [key: string]: any }\n\n  export type PaginatedSearchResultBase = {\n  query: Query;\n  sorts?: Array<Sort>;\n  limit: number;\n  hits?: Array<object>;\n  offset: any;\n  total: any;\n} & { [key: string]: any }\n\n  export type MatchAllQuery = {\n} & { [key: string]: any }\n\n  export type FilteredQuery = {\n  filter: Filter;\n  query: Query;\n} & { [key: string]: any }\n\n  export type QueryFilter = {\n  query: Query;\n} & { [key: string]: any }\n\n  export type Query = {\n  boolQuery?: BoolQuery;\n  filteredQuery?: FilteredQuery;\n  matchAllQuery?: MatchAllQuery;\n  nestedQuery?: NestedQuery;\n  termQuery?: TermQuery;\n  textQuery?: TextQuery;\n} & { [key: string]: any }\n\n  export type TermQuery = {\n  fields: Array<string>;\n  operator: string;\n  values?: Array<any>;\n} & { [key: string]: any }\n\n  export type TermFilter = {\n  field: string;\n  operator: string;\n  values?: Array<any>;\n} & { [key: string]: any }\n\n  export type TextQuery = {\n  fields: Array<string>;\n  searchPhrase: string;\n} & { [key: string]: any }\n\n  export type Range2Filter = {\n  filterMode?: string;\n  fromField: string;\n  fromInclusive?: boolean;\n  fromValue?: any;\n  toField: string;\n  toInclusive?: boolean;\n  toValue?: any;\n} & { [key: string]: any }\n\n  export type BoolQuery = {\n  must?: Array<Query>;\n  mustNot?: Array<Query>;\n  should?: Array<Query>;\n} & { [key: string]: any }\n\n  export type SimpleSearchResultBase = {\n  limit: number;\n  hits?: Array<object>;\n  offset: any;\n  total: any;\n} & { [key: string]: any }\n\n  export type NestedQuery = {\n  path: string;\n  query: Query;\n  scoreMode?: string;\n} & { [key: string]: any }\n\n  export type Filter = {\n  boolFilter?: BoolFilter;\n  queryFilter?: QueryFilter;\n  range2Filter?: Range2Filter;\n  rangeFilter?: RangeFilter;\n  termFilter?: TermFilter;\n} & { [key: string]: any }\n\n  export type Sort = {\n  field: string;\n  sortOrder?: string;\n} & { [key: string]: any }\n\n  export type SearchRequestBase = {\n  limit?: number;\n  query: Query;\n  sorts?: Array<Sort>;\n  offset?: any;\n} & { [key: string]: any }\n\n  export type MoneyMnemonic = {\n  currencyMnemonic?: string;\n  value?: number;\n} & { [key: string]: any }\n\n  export type L10nString = {\n} & { [key: string]: any }\n\n  export type AttributeDefinition = {\n  defaultValue?: PropertyValueDefinition;\n  id?: string;\n  name: L10nString;\n  description: L10nString;\n  key?: boolean;\n  localizable?: boolean;\n  mandatory?: boolean;\n  max?: number;\n  minLength?: number;\n  min?: number;\n  multiValueType?: boolean;\n  regularExpression?: string;\n  scale?: number;\n  searchable?: boolean;\n  siteSpecific?: boolean;\n  system?: boolean;\n  unit?: L10nString;\n  possibleValues?: Array<PropertyValueDefinition>;\n  type: string;\n  visible?: boolean;\n}\n  export type PropertyValueDefinition = {\n  description: L10nString;\n  displayValue: L10nString;\n  id: string;\n  position?: number;\n  value: string;\n}\n  \n/**\n * All path parameters that are used by at least one ShopperLogin method.\n */\nexport type ShopperLoginPathParameters = {\n  organizationId?: string;\n}\n/**\n * All query parameters that are used by at least one ShopperLogin method.\n */\nexport type ShopperLoginQueryParameters = {\n  client_id?: string;\n  refresh_token?: string;\n  channel_id?: string;\n  hint?: string;\n  redirect_uri?: string;\n  response_type?: string;\n  scope?: string;\n  state?: string;\n  usid?: string;\n  code_challenge?: string;\n  ui_locales?: string;\n  login_id?: string;\n  idp_origin?: string;\n}\n\n/**\n * All parameters that are used by ShopperLogin.\n */\nexport type ShopperLoginParameters = ShopperLoginPathParameters & BaseUriParameters & ShopperLoginQueryParameters;\n\n/**\n* [Shopper Login and API Access Service](https://developer.salesforce.com/docs/commerce/commerce-api/references?meta=shopper-login:Summary)\n* ==================================\n*\n* *Enable shoppers to log in more easily, stay logged in for longer, and get a more fluid and personalized shopping experience powered by Shopper APIs.*<br />\n*\n* Simple example:\n*\n* ```typescript\n*   import { ShopperLogin } from \"commerce-sdk-isomorphic\";\n*\n*   const clientConfig = {\n*     parameters: {\n*       clientId: \"XXXXXX\",\n*       organizationId: \"XXXX\",\n*       shortCode: \"XXX\",\n*       siteId: \"XX\"\n*     }\n*   };\n*   const shopperLoginClient = new ShopperLogin(clientConfig);\n* ```\n*\n* <span style=\"font-size:.7em; display:block; text-align: right\">\n* API Version: 1.39.22<br />\n* Last Updated: <br />\n* </span>\n* \n*\n*/\nexport class ShopperLogin<ConfigParameters extends ShopperLoginParameters & Record<string, unknown>> {\n  // baseUri is not required on ClientConfig, but we know that we provide one in the class constructor\n  public clientConfig: ClientConfig<ConfigParameters> & { baseUri: string };\n\n  static readonly defaultBaseUri = \"https://{shortCode}.api.commercecloud.salesforce.com/shopper/auth/{version}\";\n\n  static readonly apiPaths = {\n    authenticateCustomer: \"/organizations/{organizationId}/oauth2/login\",\n    authorizePasswordlessCustomer: \"/organizations/{organizationId}/oauth2/passwordless/login\",\n    logoutCustomer: \"/organizations/{organizationId}/oauth2/logout\",\n    authorizeCustomer: \"/organizations/{organizationId}/oauth2/authorize\",\n    getAccessToken: \"/organizations/{organizationId}/oauth2/token\",\n    getSessionBridgeAccessToken: \"/organizations/{organizationId}/oauth2/session-bridge/token\",\n    getTrustedSystemAccessToken: \"/organizations/{organizationId}/oauth2/trusted-system/token\",\n    getTrustedAgentAuthorizationToken: \"/organizations/{organizationId}/oauth2/trusted-agent/authorize\",\n    getTrustedAgentAccessToken: \"/organizations/{organizationId}/oauth2/trusted-agent/token\",\n    getPasswordResetToken: \"/organizations/{organizationId}/oauth2/password/reset\",\n    resetPassword: \"/organizations/{organizationId}/oauth2/password/action\",\n    getPasswordLessAccessToken: \"/organizations/{organizationId}/oauth2/passwordless/token\",\n    revokeToken: \"/organizations/{organizationId}/oauth2/revoke\",\n    introspectToken: \"/organizations/{organizationId}/oauth2/introspect\",\n    getUserInfo: \"/organizations/{organizationId}/oauth2/userinfo\",\n    getWellknownOpenidConfiguration: \"/organizations/{organizationId}/oauth2/.well-known/openid-configuration\",\n    getJwksUri: \"/organizations/{organizationId}/oauth2/jwks\",\n  };\n\n  constructor(config: ClientConfigInit<ConfigParameters>) {\n    const cfg = {...config}\n    if (!cfg.baseUri) cfg.baseUri = new.target.defaultBaseUri;\n    // Type assertion is safe because ^^^\n    this.clientConfig = new ClientConfig(cfg) as ClientConfig<ConfigParameters> & { baseUri: string };\n  }\n\n  static readonly paramKeys = {\n    authenticateCustomer: [\n      'organizationId',\n    ],\n    authenticateCustomerRequired: [\n      'organizationId',\n    ],\n    authorizePasswordlessCustomer: [\n      'organizationId',\n    ],\n    authorizePasswordlessCustomerRequired: [\n      'organizationId',\n    ],\n    logoutCustomer: [\n      'organizationId',\n      'client_id',\n      'refresh_token',\n      'channel_id',\n      'hint',\n    ],\n    logoutCustomerRequired: [\n      'organizationId',\n      'client_id',\n      'refresh_token',\n    ],\n    authorizeCustomer: [\n      'organizationId',\n      'redirect_uri',\n      'response_type',\n      'client_id',\n      'scope',\n      'state',\n      'usid',\n      'hint',\n      'channel_id',\n      'code_challenge',\n      'ui_locales',\n    ],\n    authorizeCustomerRequired: [\n      'organizationId',\n      'redirect_uri',\n      'response_type',\n      'client_id',\n    ],\n    getAccessToken: [\n      'organizationId',\n    ],\n    getAccessTokenRequired: [\n      'organizationId',\n    ],\n    getSessionBridgeAccessToken: [\n      'organizationId',\n    ],\n    getSessionBridgeAccessTokenRequired: [\n      'organizationId',\n    ],\n    getTrustedSystemAccessToken: [\n      'organizationId',\n    ],\n    getTrustedSystemAccessTokenRequired: [\n      'organizationId',\n    ],\n    getTrustedAgentAuthorizationToken: [\n      'organizationId',\n      'client_id',\n      'channel_id',\n      'code_challenge',\n      'login_id',\n      'idp_origin',\n      'redirect_uri',\n      'response_type',\n    ],\n    getTrustedAgentAuthorizationTokenRequired: [\n      'organizationId',\n      'client_id',\n      'channel_id',\n      'code_challenge',\n      'login_id',\n      'idp_origin',\n      'redirect_uri',\n      'response_type',\n    ],\n    getTrustedAgentAccessToken: [\n      'organizationId',\n    ],\n    getTrustedAgentAccessTokenRequired: [\n      'organizationId',\n    ],\n    getPasswordResetToken: [\n      'organizationId',\n    ],\n    getPasswordResetTokenRequired: [\n      'organizationId',\n    ],\n    resetPassword: [\n      'organizationId',\n    ],\n    resetPasswordRequired: [\n      'organizationId',\n    ],\n    getPasswordLessAccessToken: [\n      'organizationId',\n    ],\n    getPasswordLessAccessTokenRequired: [\n      'organizationId',\n    ],\n    revokeToken: [\n      'organizationId',\n    ],\n    revokeTokenRequired: [\n      'organizationId',\n    ],\n    introspectToken: [\n      'organizationId',\n    ],\n    introspectTokenRequired: [\n      'organizationId',\n    ],\n    getUserInfo: [\n      'organizationId',\n      'channel_id',\n    ],\n    getUserInfoRequired: [\n      'organizationId',\n    ],\n    getWellknownOpenidConfiguration: [\n      'organizationId',\n    ],\n    getWellknownOpenidConfigurationRequired: [\n      'organizationId',\n    ],\n    getJwksUri: [\n      'organizationId',\n    ],\n    getJwksUriRequired: [\n      'organizationId',\n    ],\n  } as const;\n  \n      /**\n      * Logs in a shopper with credentials that are managed by a B2C Commerce instance (ECOM). It follows the authorization code grant flow as defined by the OAuth 2.1 standard. It also uses a proof key for code exchange (PKCE).\n  \n  For PKCE values:\n  - The `code_verifier` string is a random string used for the `/token` endpoint request.\n  - The `code_challenge` is an encoded version of the `code_verifier` string using an SHA-256 hash.\n  \n    The request must include a basic authorization header that contains a Base64 encoded version of the following string: `\\<shopperUserID\\>:\\<shopperPassword\\>`.\n  \n    Required parameters: `code_challenge`, `channel_id`, `client_id`, and `redirect_uri`.\n  \n    Optional parameters: `usid`.\n  \n    The SLAS `/login` endpoint redirects back to the redirect URI and returns an authorization code.\n  \n    Calls to `/login` made with the same loginId and tenantId within 1 second will result in a conflict.\n  \n      *\n      * If you would like to get a raw Response object use the other authenticateCustomer function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type void.\n      * \n      */\n      authenticateCustomer(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: LoginRequest\n        }>\n      ): Promise<void>;\n  \n      /**\n      * Logs in a shopper with credentials that are managed by a B2C Commerce instance (ECOM). It follows the authorization code grant flow as defined by the OAuth 2.1 standard. It also uses a proof key for code exchange (PKCE).\n  \n  For PKCE values:\n  - The `code_verifier` string is a random string used for the `/token` endpoint request.\n  - The `code_challenge` is an encoded version of the `code_verifier` string using an SHA-256 hash.\n  \n    The request must include a basic authorization header that contains a Base64 encoded version of the following string: `\\<shopperUserID\\>:\\<shopperPassword\\>`.\n  \n    Required parameters: `code_challenge`, `channel_id`, `client_id`, and `redirect_uri`.\n  \n    Optional parameters: `usid`.\n  \n    The SLAS `/login` endpoint redirects back to the redirect URI and returns an authorization code.\n  \n    Calls to `/login` made with the same loginId and tenantId within 1 second will result in a conflict.\n  \n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      authenticateCustomer<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: LoginRequest\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : void>;\n  \n      /**\n      * Logs in a shopper with credentials that are managed by a B2C Commerce instance (ECOM). It follows the authorization code grant flow as defined by the OAuth 2.1 standard. It also uses a proof key for code exchange (PKCE).\n  \n  For PKCE values:\n  - The `code_verifier` string is a random string used for the `/token` endpoint request.\n  - The `code_challenge` is an encoded version of the `code_verifier` string using an SHA-256 hash.\n  \n    The request must include a basic authorization header that contains a Base64 encoded version of the following string: `\\<shopperUserID\\>:\\<shopperPassword\\>`.\n  \n    Required parameters: `code_challenge`, `channel_id`, `client_id`, and `redirect_uri`.\n  \n    Optional parameters: `usid`.\n  \n    The SLAS `/login` endpoint redirects back to the redirect URI and returns an authorization code.\n  \n    Calls to `/login` made with the same loginId and tenantId within 1 second will result in a conflict.\n  \n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      async authenticateCustomer(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: LoginRequest\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | void> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperLoginPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperLoginQueryParameters & { [key in `c_${string}`]: any } = {};\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for authenticateCustomer: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/oauth2/login\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/x-www-form-urlencoded\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        if (rawResponse) {\n          return response as Response;\n        }\n      }\n  \n      /**\n      * Allows the customer to authenticate when their identity provider is down.\n      *\n      * If you would like to get a raw Response object use the other authorizePasswordlessCustomer function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type Object.\n      * \n      */\n      authorizePasswordlessCustomer(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: PasswordlessLoginRequest\n        }>\n      ): Promise<Object>;\n  \n      /**\n      * Allows the customer to authenticate when their identity provider is down.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type Object otherwise.\n      * \n      */\n      authorizePasswordlessCustomer<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: PasswordlessLoginRequest\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : Object>;\n  \n      /**\n      * Allows the customer to authenticate when their identity provider is down.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type Object otherwise.\n      * \n      */\n      async authorizePasswordlessCustomer(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: PasswordlessLoginRequest\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | Object> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperLoginPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperLoginQueryParameters & { [key in `c_${string}`]: any } = {};\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for authorizePasswordlessCustomer: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/oauth2/passwordless/login\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/x-www-form-urlencoded\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | Object;\n      }\n  \n      /**\n      * Log out a shopper. The shopper's access token and refresh token are revoked. If the shopper authenticated with a B2C Commerce (ECOM) instance, the OCAPI JWT is also revoked. This should be called for Registered users that have logged in using SLAS. his should be called for registered users that have logged in using SLAS. This endpoint is not for use with guest users.\n  \n  Required header: Authorization header bearer token of the Shopper access token to logout.\n  \n  Required parameters: `refresh token`, `channel_id`, and `client`.\n      *\n      * If you would like to get a raw Response object use the other logoutCustomer function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param client_id - The SLAS client ID.\n      * @param refresh_token - Refresh token that was given during the access token request.\n      * @param channel_id - The `channel_id` parameter must be provided if the shopper authenticated using the `login` endpoint with ECOM.\n      * @param hint - Optional parameter for logging out user sessions. Use `all-sessions` to log out all user sessions. If `hint` is not used, only the current user session will be logged out.\n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type TokenResponse.\n      * \n      */\n      logoutCustomer(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            client_id: string\n            refresh_token: string\n            channel_id?: string\n            hint?: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<TokenResponse>;\n  \n      /**\n      * Log out a shopper. The shopper's access token and refresh token are revoked. If the shopper authenticated with a B2C Commerce (ECOM) instance, the OCAPI JWT is also revoked. This should be called for Registered users that have logged in using SLAS. his should be called for registered users that have logged in using SLAS. This endpoint is not for use with guest users.\n  \n  Required header: Authorization header bearer token of the Shopper access token to logout.\n  \n  Required parameters: `refresh token`, `channel_id`, and `client`.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param client_id - The SLAS client ID.\n      * @param refresh_token - Refresh token that was given during the access token request.\n      * @param channel_id - The `channel_id` parameter must be provided if the shopper authenticated using the `login` endpoint with ECOM.\n      * @param hint - Optional parameter for logging out user sessions. Use `all-sessions` to log out all user sessions. If `hint` is not used, only the current user session will be logged out.\n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type TokenResponse otherwise.\n      * \n      */\n      logoutCustomer<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            client_id: string\n            refresh_token: string\n            channel_id?: string\n            hint?: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : TokenResponse>;\n  \n      /**\n      * Log out a shopper. The shopper's access token and refresh token are revoked. If the shopper authenticated with a B2C Commerce (ECOM) instance, the OCAPI JWT is also revoked. This should be called for Registered users that have logged in using SLAS. his should be called for registered users that have logged in using SLAS. This endpoint is not for use with guest users.\n  \n  Required header: Authorization header bearer token of the Shopper access token to logout.\n  \n  Required parameters: `refresh token`, `channel_id`, and `client`.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param client_id - The SLAS client ID.\n      * @param refresh_token - Refresh token that was given during the access token request.\n      * @param channel_id - The `channel_id` parameter must be provided if the shopper authenticated using the `login` endpoint with ECOM.\n      * @param hint - Optional parameter for logging out user sessions. Use `all-sessions` to log out all user sessions. If `hint` is not used, only the current user session will be logged out.\n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type TokenResponse otherwise.\n      * \n      */\n      async logoutCustomer(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            client_id: string\n            refresh_token: string\n            channel_id?: string\n            hint?: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | TokenResponse> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperLoginPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperLoginQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"client_id\"] !== undefined) {\n          queryParams[\"client_id\"] = optionParams[\"client_id\"];\n        } else if (configParams[\"client_id\"] !== undefined) {\n          queryParams[\"client_id\"] = configParams[\"client_id\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: client_id');\n        }\n        if (optionParams[\"refresh_token\"] !== undefined) {\n          queryParams[\"refresh_token\"] = optionParams[\"refresh_token\"];\n        } else if (configParams[\"refresh_token\"] !== undefined) {\n          queryParams[\"refresh_token\"] = configParams[\"refresh_token\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: refresh_token');\n        }\n        if (optionParams[\"channel_id\"] !== undefined) {\n          queryParams[\"channel_id\"] = optionParams[\"channel_id\"];\n        } else if (configParams[\"channel_id\"] !== undefined) {\n          queryParams[\"channel_id\"] = configParams[\"channel_id\"];\n        }\n        if (optionParams[\"hint\"] !== undefined) {\n          queryParams[\"hint\"] = optionParams[\"hint\"];\n        } else if (configParams[\"hint\"] !== undefined) {\n          queryParams[\"hint\"] = configParams[\"hint\"];\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for logoutCustomer: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/oauth2/logout\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"GET\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | TokenResponse;\n      }\n  \n      /**\n      * Get an authorization code after authenticating a user against an identity provider (IDP). This is the first step of the OAuth 2.1 authorization code flow, where a user can log in via federation to the IDP configured for the client. After successfully logging in, the user gets an authorization code via a redirect URI.\n  \n  This endpoint can be called from the front channel (the browser).\n      *\n      * If you would like to get a raw Response object use the other authorizeCustomer function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param redirect_uri - The URL to which the server redirects the browser after the user grants the authorization. The URI must be pre-registered. A variety of URI formats and wildcard for host are supported, but app links like `airbnb://` or `fb://` are not. Examples of supported URIs:\n    - `http://localhost:3000/callback`\n    - `https://example.com/callback`\n    - `com.example.app:redirect_uri_path`\n    - ` *.subdomain.topleveldomain.com`\n  \n      * @param response_type - Must be `code`. Indicates that the client wants an authorization code (using the `authorization_code` grant type).\n      * @param client_id - The client ID obtained during application registration.\n      * @param scope - \n      * @param state - Value to send the client to determine the state between the authorization request and the server response. Optional, but strongly recommended.\n      * @param usid - A unique shopper identifier (USID). If not provided, a new USID is generated.\n      * @param hint - Name of an identity provider (IDP) to optionally redirect to, thereby skipping the IDP selection step.\n  \n  To use a public client, set `hint` to `guest` and use a public client ID to get an authorization code. If no `hint` is provided, the preferred IDP of the tenant is used by default.\n  \n  For session bridge authorization the `hint` should be set to `sb-user` for a registered customer and to `sb-guest` for a guest.\n      * @param channel_id - The channel that this request is for. For an ECOM request, this is angalous to the site ID.\n      * @param code_challenge - PKCE code challenge. Created by the client calling the `login` endpoint.\n  \n  The `code_challenge` is created by SHA256 hashing the `code_verifier` and Base64 encoding the resulting hash.\n  \n  The `code_verifier` should be a high entropy cryptographically random string with a minimum of 43 characters and a maximum of 128 characters.\n      * @param ui_locales - End-User's preferred languages and scripts for the user interface, represented as a space-separated list of BCP47 [RFC5646] language tag values, ordered by preference. For example, the value `fr-CA fr en` represents a preference for French as spoken in Canada, then French (without a region designation), followed by English (without a region designation). \n  \n  In most cases the IDP supports one language tag and has a default language set on the server. SLAS will support the space-separated list and pass them to the IDP.\n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type void.\n      * \n      */\n      authorizeCustomer(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            redirect_uri: string\n            response_type: string\n            client_id: string\n            scope?: string\n            state?: string\n            usid?: string\n            hint?: string\n            channel_id?: string\n            code_challenge?: string\n            ui_locales?: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<void>;\n  \n      /**\n      * Get an authorization code after authenticating a user against an identity provider (IDP). This is the first step of the OAuth 2.1 authorization code flow, where a user can log in via federation to the IDP configured for the client. After successfully logging in, the user gets an authorization code via a redirect URI.\n  \n  This endpoint can be called from the front channel (the browser).\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param redirect_uri - The URL to which the server redirects the browser after the user grants the authorization. The URI must be pre-registered. A variety of URI formats and wildcard for host are supported, but app links like `airbnb://` or `fb://` are not. Examples of supported URIs:\n    - `http://localhost:3000/callback`\n    - `https://example.com/callback`\n    - `com.example.app:redirect_uri_path`\n    - ` *.subdomain.topleveldomain.com`\n  \n      * @param response_type - Must be `code`. Indicates that the client wants an authorization code (using the `authorization_code` grant type).\n      * @param client_id - The client ID obtained during application registration.\n      * @param scope - \n      * @param state - Value to send the client to determine the state between the authorization request and the server response. Optional, but strongly recommended.\n      * @param usid - A unique shopper identifier (USID). If not provided, a new USID is generated.\n      * @param hint - Name of an identity provider (IDP) to optionally redirect to, thereby skipping the IDP selection step.\n  \n  To use a public client, set `hint` to `guest` and use a public client ID to get an authorization code. If no `hint` is provided, the preferred IDP of the tenant is used by default.\n  \n  For session bridge authorization the `hint` should be set to `sb-user` for a registered customer and to `sb-guest` for a guest.\n      * @param channel_id - The channel that this request is for. For an ECOM request, this is angalous to the site ID.\n      * @param code_challenge - PKCE code challenge. Created by the client calling the `login` endpoint.\n  \n  The `code_challenge` is created by SHA256 hashing the `code_verifier` and Base64 encoding the resulting hash.\n  \n  The `code_verifier` should be a high entropy cryptographically random string with a minimum of 43 characters and a maximum of 128 characters.\n      * @param ui_locales - End-User's preferred languages and scripts for the user interface, represented as a space-separated list of BCP47 [RFC5646] language tag values, ordered by preference. For example, the value `fr-CA fr en` represents a preference for French as spoken in Canada, then French (without a region designation), followed by English (without a region designation). \n  \n  In most cases the IDP supports one language tag and has a default language set on the server. SLAS will support the space-separated list and pass them to the IDP.\n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      authorizeCustomer<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            redirect_uri: string\n            response_type: string\n            client_id: string\n            scope?: string\n            state?: string\n            usid?: string\n            hint?: string\n            channel_id?: string\n            code_challenge?: string\n            ui_locales?: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : void>;\n  \n      /**\n      * Get an authorization code after authenticating a user against an identity provider (IDP). This is the first step of the OAuth 2.1 authorization code flow, where a user can log in via federation to the IDP configured for the client. After successfully logging in, the user gets an authorization code via a redirect URI.\n  \n  This endpoint can be called from the front channel (the browser).\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param redirect_uri - The URL to which the server redirects the browser after the user grants the authorization. The URI must be pre-registered. A variety of URI formats and wildcard for host are supported, but app links like `airbnb://` or `fb://` are not. Examples of supported URIs:\n    - `http://localhost:3000/callback`\n    - `https://example.com/callback`\n    - `com.example.app:redirect_uri_path`\n    - ` *.subdomain.topleveldomain.com`\n  \n      * @param response_type - Must be `code`. Indicates that the client wants an authorization code (using the `authorization_code` grant type).\n      * @param client_id - The client ID obtained during application registration.\n      * @param scope - \n      * @param state - Value to send the client to determine the state between the authorization request and the server response. Optional, but strongly recommended.\n      * @param usid - A unique shopper identifier (USID). If not provided, a new USID is generated.\n      * @param hint - Name of an identity provider (IDP) to optionally redirect to, thereby skipping the IDP selection step.\n  \n  To use a public client, set `hint` to `guest` and use a public client ID to get an authorization code. If no `hint` is provided, the preferred IDP of the tenant is used by default.\n  \n  For session bridge authorization the `hint` should be set to `sb-user` for a registered customer and to `sb-guest` for a guest.\n      * @param channel_id - The channel that this request is for. For an ECOM request, this is angalous to the site ID.\n      * @param code_challenge - PKCE code challenge. Created by the client calling the `login` endpoint.\n  \n  The `code_challenge` is created by SHA256 hashing the `code_verifier` and Base64 encoding the resulting hash.\n  \n  The `code_verifier` should be a high entropy cryptographically random string with a minimum of 43 characters and a maximum of 128 characters.\n      * @param ui_locales - End-User's preferred languages and scripts for the user interface, represented as a space-separated list of BCP47 [RFC5646] language tag values, ordered by preference. For example, the value `fr-CA fr en` represents a preference for French as spoken in Canada, then French (without a region designation), followed by English (without a region designation). \n  \n  In most cases the IDP supports one language tag and has a default language set on the server. SLAS will support the space-separated list and pass them to the IDP.\n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      async authorizeCustomer(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            redirect_uri: string\n            response_type: string\n            client_id: string\n            scope?: string\n            state?: string\n            usid?: string\n            hint?: string\n            channel_id?: string\n            code_challenge?: string\n            ui_locales?: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | void> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperLoginPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperLoginQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"redirect_uri\"] !== undefined) {\n          queryParams[\"redirect_uri\"] = optionParams[\"redirect_uri\"];\n        } else if (configParams[\"redirect_uri\"] !== undefined) {\n          queryParams[\"redirect_uri\"] = configParams[\"redirect_uri\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: redirect_uri');\n        }\n        if (optionParams[\"response_type\"] !== undefined) {\n          queryParams[\"response_type\"] = optionParams[\"response_type\"];\n        } else if (configParams[\"response_type\"] !== undefined) {\n          queryParams[\"response_type\"] = configParams[\"response_type\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: response_type');\n        }\n        if (optionParams[\"client_id\"] !== undefined) {\n          queryParams[\"client_id\"] = optionParams[\"client_id\"];\n        } else if (configParams[\"client_id\"] !== undefined) {\n          queryParams[\"client_id\"] = configParams[\"client_id\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: client_id');\n        }\n        if (optionParams[\"scope\"] !== undefined) {\n          queryParams[\"scope\"] = optionParams[\"scope\"];\n        } else if (configParams[\"scope\"] !== undefined) {\n          queryParams[\"scope\"] = configParams[\"scope\"];\n        }\n        if (optionParams[\"state\"] !== undefined) {\n          queryParams[\"state\"] = optionParams[\"state\"];\n        } else if (configParams[\"state\"] !== undefined) {\n          queryParams[\"state\"] = configParams[\"state\"];\n        }\n        if (optionParams[\"usid\"] !== undefined) {\n          queryParams[\"usid\"] = optionParams[\"usid\"];\n        } else if (configParams[\"usid\"] !== undefined) {\n          queryParams[\"usid\"] = configParams[\"usid\"];\n        }\n        if (optionParams[\"hint\"] !== undefined) {\n          queryParams[\"hint\"] = optionParams[\"hint\"];\n        } else if (configParams[\"hint\"] !== undefined) {\n          queryParams[\"hint\"] = configParams[\"hint\"];\n        }\n        if (optionParams[\"channel_id\"] !== undefined) {\n          queryParams[\"channel_id\"] = optionParams[\"channel_id\"];\n        } else if (configParams[\"channel_id\"] !== undefined) {\n          queryParams[\"channel_id\"] = configParams[\"channel_id\"];\n        }\n        if (optionParams[\"code_challenge\"] !== undefined) {\n          queryParams[\"code_challenge\"] = optionParams[\"code_challenge\"];\n        } else if (configParams[\"code_challenge\"] !== undefined) {\n          queryParams[\"code_challenge\"] = configParams[\"code_challenge\"];\n        }\n        if (optionParams[\"ui_locales\"] !== undefined) {\n          queryParams[\"ui_locales\"] = optionParams[\"ui_locales\"];\n        } else if (configParams[\"ui_locales\"] !== undefined) {\n          queryParams[\"ui_locales\"] = configParams[\"ui_locales\"];\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for authorizeCustomer: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/oauth2/authorize\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"GET\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        if (rawResponse) {\n          return response as Response;\n        }\n      }\n  \n      /**\n      * Get the shopper or guest JWT access token and a refresh token. This is the second step of the OAuth 2.1 authorization code flow.\n  \n  For a private client, an application is able to get an access token for the shopper through the back channel (a trusted server) by passing in the client credentials and the authorization code retrieved from the `authorize` endpoint.\n  \n  For a guest user, get the shopper JWT access token and a refresh token. This is where a client appplication is able to get an access token for the guest user through the back channel (a trusted server) by passing in the client credentials.\n  \n  For a public client using PKCE, an application will pass a PKCE `code_verifier` that matches the `code_challenge` that was used to `authorize` the customer along with the authorization code.\n  \n  When refreshing the access token with a private client ID and client secret, the refresh token is _not_ regenerated. However, when refreshing the access token with a public client ID, the refresh token is _always_ regenerated. The old refresh token is voided with every refresh call, so the refresh token on the client needs to be replaced to always store the new refresh token.\n  \n  See the Body section for required parameters, including `grant_type` and others, depending on the value of `grant_type`.\n  \n  **Important**: We strongly recommended using the `channel_id` query parameter because **it will be required in the future**.\n      *\n      * If you would like to get a raw Response object use the other getAccessToken function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type TokenResponse.\n      * \n      */\n      getAccessToken(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: TokenRequest\n        }>\n      ): Promise<TokenResponse>;\n  \n      /**\n      * Get the shopper or guest JWT access token and a refresh token. This is the second step of the OAuth 2.1 authorization code flow.\n  \n  For a private client, an application is able to get an access token for the shopper through the back channel (a trusted server) by passing in the client credentials and the authorization code retrieved from the `authorize` endpoint.\n  \n  For a guest user, get the shopper JWT access token and a refresh token. This is where a client appplication is able to get an access token for the guest user through the back channel (a trusted server) by passing in the client credentials.\n  \n  For a public client using PKCE, an application will pass a PKCE `code_verifier` that matches the `code_challenge` that was used to `authorize` the customer along with the authorization code.\n  \n  When refreshing the access token with a private client ID and client secret, the refresh token is _not_ regenerated. However, when refreshing the access token with a public client ID, the refresh token is _always_ regenerated. The old refresh token is voided with every refresh call, so the refresh token on the client needs to be replaced to always store the new refresh token.\n  \n  See the Body section for required parameters, including `grant_type` and others, depending on the value of `grant_type`.\n  \n  **Important**: We strongly recommended using the `channel_id` query parameter because **it will be required in the future**.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type TokenResponse otherwise.\n      * \n      */\n      getAccessToken<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: TokenRequest\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : TokenResponse>;\n  \n      /**\n      * Get the shopper or guest JWT access token and a refresh token. This is the second step of the OAuth 2.1 authorization code flow.\n  \n  For a private client, an application is able to get an access token for the shopper through the back channel (a trusted server) by passing in the client credentials and the authorization code retrieved from the `authorize` endpoint.\n  \n  For a guest user, get the shopper JWT access token and a refresh token. This is where a client appplication is able to get an access token for the guest user through the back channel (a trusted server) by passing in the client credentials.\n  \n  For a public client using PKCE, an application will pass a PKCE `code_verifier` that matches the `code_challenge` that was used to `authorize` the customer along with the authorization code.\n  \n  When refreshing the access token with a private client ID and client secret, the refresh token is _not_ regenerated. However, when refreshing the access token with a public client ID, the refresh token is _always_ regenerated. The old refresh token is voided with every refresh call, so the refresh token on the client needs to be replaced to always store the new refresh token.\n  \n  See the Body section for required parameters, including `grant_type` and others, depending on the value of `grant_type`.\n  \n  **Important**: We strongly recommended using the `channel_id` query parameter because **it will be required in the future**.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type TokenResponse otherwise.\n      * \n      */\n      async getAccessToken(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: TokenRequest\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | TokenResponse> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperLoginPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperLoginQueryParameters & { [key in `c_${string}`]: any } = {};\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getAccessToken: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/oauth2/token\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/x-www-form-urlencoded\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | TokenResponse;\n      }\n  \n      /**\n      * Get a shopper JWT access token for a registered customer using session bridge.\n  \n  For public client id requests the grant_type must be set to `session_bridge`.\n  \n  For  private client_id and secret the grant_type must be set to `client_credentials` along with a basic authorization header.\n  \n  **DEPRECATED** - As of January 31, 2024, SLAS will no longer support the SESB `dwsid` parameter for `guest` users for `session-bridge/token` calls. It is recommended to transition over to using a SESB `dwsgst` token. \n  \n  The `dwsid` will still be needed for `registered` user `session-bridge/token` calls.\n      *\n      * If you would like to get a raw Response object use the other getSessionBridgeAccessToken function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type TokenResponse.\n      * \n      */\n      getSessionBridgeAccessToken(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: SessionBridgeTokenRequest\n        }>\n      ): Promise<TokenResponse>;\n  \n      /**\n      * Get a shopper JWT access token for a registered customer using session bridge.\n  \n  For public client id requests the grant_type must be set to `session_bridge`.\n  \n  For  private client_id and secret the grant_type must be set to `client_credentials` along with a basic authorization header.\n  \n  **DEPRECATED** - As of January 31, 2024, SLAS will no longer support the SESB `dwsid` parameter for `guest` users for `session-bridge/token` calls. It is recommended to transition over to using a SESB `dwsgst` token. \n  \n  The `dwsid` will still be needed for `registered` user `session-bridge/token` calls.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type TokenResponse otherwise.\n      * \n      */\n      getSessionBridgeAccessToken<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: SessionBridgeTokenRequest\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : TokenResponse>;\n  \n      /**\n      * Get a shopper JWT access token for a registered customer using session bridge.\n  \n  For public client id requests the grant_type must be set to `session_bridge`.\n  \n  For  private client_id and secret the grant_type must be set to `client_credentials` along with a basic authorization header.\n  \n  **DEPRECATED** - As of January 31, 2024, SLAS will no longer support the SESB `dwsid` parameter for `guest` users for `session-bridge/token` calls. It is recommended to transition over to using a SESB `dwsgst` token. \n  \n  The `dwsid` will still be needed for `registered` user `session-bridge/token` calls.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type TokenResponse otherwise.\n      * \n      */\n      async getSessionBridgeAccessToken(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: SessionBridgeTokenRequest\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | TokenResponse> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperLoginPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperLoginQueryParameters & { [key in `c_${string}`]: any } = {};\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getSessionBridgeAccessToken: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/oauth2/session-bridge/token\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/x-www-form-urlencoded\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | TokenResponse;\n      }\n  \n      /**\n      * Get a shopper JWT access token for a registered customer whose credentials are stored using a third party system.\n  \n  For trusted-system requests, a basic authorization header that includes a SLAS client ID and SLAS client secret can be used in place of the bearer token.\n      *\n      * If you would like to get a raw Response object use the other getTrustedSystemAccessToken function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type TokenResponse.\n      * \n      */\n      getTrustedSystemAccessToken(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: TrustedSystemTokenRequest\n        }>\n      ): Promise<TokenResponse>;\n  \n      /**\n      * Get a shopper JWT access token for a registered customer whose credentials are stored using a third party system.\n  \n  For trusted-system requests, a basic authorization header that includes a SLAS client ID and SLAS client secret can be used in place of the bearer token.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type TokenResponse otherwise.\n      * \n      */\n      getTrustedSystemAccessToken<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: TrustedSystemTokenRequest\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : TokenResponse>;\n  \n      /**\n      * Get a shopper JWT access token for a registered customer whose credentials are stored using a third party system.\n  \n  For trusted-system requests, a basic authorization header that includes a SLAS client ID and SLAS client secret can be used in place of the bearer token.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type TokenResponse otherwise.\n      * \n      */\n      async getTrustedSystemAccessToken(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: TrustedSystemTokenRequest\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | TokenResponse> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperLoginPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperLoginQueryParameters & { [key in `c_${string}`]: any } = {};\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getTrustedSystemAccessToken: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/oauth2/trusted-system/token\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/x-www-form-urlencoded\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | TokenResponse;\n      }\n  \n      /**\n      * Obtains a new agent on behalf authorization token for a registered customer.\n      *\n      * If you would like to get a raw Response object use the other getTrustedAgentAuthorizationToken function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param client_id - The SLAS public client ID or SLAS private client ID for use with trusted-agent requests. When using a private client ID a PKCE code challenge is not required.\n      * @param channel_id - The channel (ECOM site) that the user is associated with.\n      * @param code_challenge - PKCE code challenge. Created by the caller.\n  \n  The `code_challenge` is created by SHA256 hashing the `code_verifier` and Base64 encoding the resulting hash.\n  \n  The `code_verifier` should be a high entropy cryptographically random string with a minimum of 43 characters and a maximum of 128 characters.\n  \n  The `code_challenge` is not needed if a using SLAS private `client_id`.\n      * @param login_id - The ID of the shopper for trusted agent access.\n      * @param idp_origin - The IDP that the shopper is associated with.\n      * @param redirect_uri - The redirect for Account Manager to redirect to. A variety of URI formats and wildcard for host are supported, but app links like `airbnb://` or `fb://` are not. Examples of supported URIs:\n    - `http://localhost:3000/callback`\n    - `https://example.com/callback`\n    - `com.example.app:redirect_uri_path`\n    - ` *.subdomain.topleveldomain.com`\n  \n      * @param response_type - Must be `code`. Indicates that the caller wants an authorization code.\n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type void.\n      * \n      */\n      getTrustedAgentAuthorizationToken(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            client_id: string\n            channel_id: string\n            code_challenge: string\n            login_id: string\n            idp_origin: string\n            redirect_uri: string\n            response_type: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<void>;\n  \n      /**\n      * Obtains a new agent on behalf authorization token for a registered customer.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param client_id - The SLAS public client ID or SLAS private client ID for use with trusted-agent requests. When using a private client ID a PKCE code challenge is not required.\n      * @param channel_id - The channel (ECOM site) that the user is associated with.\n      * @param code_challenge - PKCE code challenge. Created by the caller.\n  \n  The `code_challenge` is created by SHA256 hashing the `code_verifier` and Base64 encoding the resulting hash.\n  \n  The `code_verifier` should be a high entropy cryptographically random string with a minimum of 43 characters and a maximum of 128 characters.\n  \n  The `code_challenge` is not needed if a using SLAS private `client_id`.\n      * @param login_id - The ID of the shopper for trusted agent access.\n      * @param idp_origin - The IDP that the shopper is associated with.\n      * @param redirect_uri - The redirect for Account Manager to redirect to. A variety of URI formats and wildcard for host are supported, but app links like `airbnb://` or `fb://` are not. Examples of supported URIs:\n    - `http://localhost:3000/callback`\n    - `https://example.com/callback`\n    - `com.example.app:redirect_uri_path`\n    - ` *.subdomain.topleveldomain.com`\n  \n      * @param response_type - Must be `code`. Indicates that the caller wants an authorization code.\n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      getTrustedAgentAuthorizationToken<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            client_id: string\n            channel_id: string\n            code_challenge: string\n            login_id: string\n            idp_origin: string\n            redirect_uri: string\n            response_type: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : void>;\n  \n      /**\n      * Obtains a new agent on behalf authorization token for a registered customer.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param client_id - The SLAS public client ID or SLAS private client ID for use with trusted-agent requests. When using a private client ID a PKCE code challenge is not required.\n      * @param channel_id - The channel (ECOM site) that the user is associated with.\n      * @param code_challenge - PKCE code challenge. Created by the caller.\n  \n  The `code_challenge` is created by SHA256 hashing the `code_verifier` and Base64 encoding the resulting hash.\n  \n  The `code_verifier` should be a high entropy cryptographically random string with a minimum of 43 characters and a maximum of 128 characters.\n  \n  The `code_challenge` is not needed if a using SLAS private `client_id`.\n      * @param login_id - The ID of the shopper for trusted agent access.\n      * @param idp_origin - The IDP that the shopper is associated with.\n      * @param redirect_uri - The redirect for Account Manager to redirect to. A variety of URI formats and wildcard for host are supported, but app links like `airbnb://` or `fb://` are not. Examples of supported URIs:\n    - `http://localhost:3000/callback`\n    - `https://example.com/callback`\n    - `com.example.app:redirect_uri_path`\n    - ` *.subdomain.topleveldomain.com`\n  \n      * @param response_type - Must be `code`. Indicates that the caller wants an authorization code.\n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      async getTrustedAgentAuthorizationToken(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            client_id: string\n            channel_id: string\n            code_challenge: string\n            login_id: string\n            idp_origin: string\n            redirect_uri: string\n            response_type: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | void> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperLoginPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperLoginQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"client_id\"] !== undefined) {\n          queryParams[\"client_id\"] = optionParams[\"client_id\"];\n        } else if (configParams[\"client_id\"] !== undefined) {\n          queryParams[\"client_id\"] = configParams[\"client_id\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: client_id');\n        }\n        if (optionParams[\"channel_id\"] !== undefined) {\n          queryParams[\"channel_id\"] = optionParams[\"channel_id\"];\n        } else if (configParams[\"channel_id\"] !== undefined) {\n          queryParams[\"channel_id\"] = configParams[\"channel_id\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: channel_id');\n        }\n        if (optionParams[\"code_challenge\"] !== undefined) {\n          queryParams[\"code_challenge\"] = optionParams[\"code_challenge\"];\n        } else if (configParams[\"code_challenge\"] !== undefined) {\n          queryParams[\"code_challenge\"] = configParams[\"code_challenge\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: code_challenge');\n        }\n        if (optionParams[\"login_id\"] !== undefined) {\n          queryParams[\"login_id\"] = optionParams[\"login_id\"];\n        } else if (configParams[\"login_id\"] !== undefined) {\n          queryParams[\"login_id\"] = configParams[\"login_id\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: login_id');\n        }\n        if (optionParams[\"idp_origin\"] !== undefined) {\n          queryParams[\"idp_origin\"] = optionParams[\"idp_origin\"];\n        } else if (configParams[\"idp_origin\"] !== undefined) {\n          queryParams[\"idp_origin\"] = configParams[\"idp_origin\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: idp_origin');\n        }\n        if (optionParams[\"redirect_uri\"] !== undefined) {\n          queryParams[\"redirect_uri\"] = optionParams[\"redirect_uri\"];\n        } else if (configParams[\"redirect_uri\"] !== undefined) {\n          queryParams[\"redirect_uri\"] = configParams[\"redirect_uri\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: redirect_uri');\n        }\n        if (optionParams[\"response_type\"] !== undefined) {\n          queryParams[\"response_type\"] = optionParams[\"response_type\"];\n        } else if (configParams[\"response_type\"] !== undefined) {\n          queryParams[\"response_type\"] = configParams[\"response_type\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: response_type');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getTrustedAgentAuthorizationToken: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/oauth2/trusted-agent/authorize\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"GET\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        if (rawResponse) {\n          return response as Response;\n        }\n      }\n  \n      /**\n      * Get a shopper JWT access token for a registered customer using a trusted agent (merchant).\n  \n  If using a SLAS private client ID, you must also use an `_sfdc_client_auth` header. \n  \n  The value of the `_sfdc_client_auth` header must be a Base64-encoded string. The string is composed of a SLAS private client ID and client secret, separated by a colon (`:`). For example, `privateClientId:privateClientsecret` becomes `cHJpdmF0ZUNsaWVudElkOnByaXZhdGVDbGllbnRzZWNyZXQ=` after Base64 encoding.\n      *\n      * If you would like to get a raw Response object use the other getTrustedAgentAccessToken function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type TokenResponse.\n      * \n      */\n      getTrustedAgentAccessToken(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: TrustedAgentTokenRequest\n        }>\n      ): Promise<TokenResponse>;\n  \n      /**\n      * Get a shopper JWT access token for a registered customer using a trusted agent (merchant).\n  \n  If using a SLAS private client ID, you must also use an `_sfdc_client_auth` header. \n  \n  The value of the `_sfdc_client_auth` header must be a Base64-encoded string. The string is composed of a SLAS private client ID and client secret, separated by a colon (`:`). For example, `privateClientId:privateClientsecret` becomes `cHJpdmF0ZUNsaWVudElkOnByaXZhdGVDbGllbnRzZWNyZXQ=` after Base64 encoding.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type TokenResponse otherwise.\n      * \n      */\n      getTrustedAgentAccessToken<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: TrustedAgentTokenRequest\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : TokenResponse>;\n  \n      /**\n      * Get a shopper JWT access token for a registered customer using a trusted agent (merchant).\n  \n  If using a SLAS private client ID, you must also use an `_sfdc_client_auth` header. \n  \n  The value of the `_sfdc_client_auth` header must be a Base64-encoded string. The string is composed of a SLAS private client ID and client secret, separated by a colon (`:`). For example, `privateClientId:privateClientsecret` becomes `cHJpdmF0ZUNsaWVudElkOnByaXZhdGVDbGllbnRzZWNyZXQ=` after Base64 encoding.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type TokenResponse otherwise.\n      * \n      */\n      async getTrustedAgentAccessToken(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: TrustedAgentTokenRequest\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | TokenResponse> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperLoginPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperLoginQueryParameters & { [key in `c_${string}`]: any } = {};\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getTrustedAgentAccessToken: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/oauth2/trusted-agent/token\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/x-www-form-urlencoded\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | TokenResponse;\n      }\n  \n      /**\n      * Request a reset password token\n      *\n      * If you would like to get a raw Response object use the other getPasswordResetToken function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type void.\n      * \n      */\n      getPasswordResetToken(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: PasswordActionRequest\n        }>\n      ): Promise<void>;\n  \n      /**\n      * Request a reset password token\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      getPasswordResetToken<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: PasswordActionRequest\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : void>;\n  \n      /**\n      * Request a reset password token\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      async getPasswordResetToken(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: PasswordActionRequest\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | void> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperLoginPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperLoginQueryParameters & { [key in `c_${string}`]: any } = {};\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getPasswordResetToken: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/oauth2/password/reset\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/x-www-form-urlencoded\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        if (rawResponse) {\n          return response as Response;\n        }\n      }\n  \n      /**\n      * Creates a new password\n      *\n      * If you would like to get a raw Response object use the other resetPassword function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type void.\n      * \n      */\n      resetPassword(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: PasswordActionVerifyRequest\n        }>\n      ): Promise<void>;\n  \n      /**\n      * Creates a new password\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      resetPassword<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: PasswordActionVerifyRequest\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : void>;\n  \n      /**\n      * Creates a new password\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      async resetPassword(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: PasswordActionVerifyRequest\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | void> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperLoginPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperLoginQueryParameters & { [key in `c_${string}`]: any } = {};\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for resetPassword: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/oauth2/password/action\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/x-www-form-urlencoded\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        if (rawResponse) {\n          return response as Response;\n        }\n      }\n  \n      /**\n      * Issue a shopper token (JWT).\n      *\n      * If you would like to get a raw Response object use the other getPasswordLessAccessToken function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type TokenResponse.\n      * \n      */\n      getPasswordLessAccessToken(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: PasswordLessLoginTokenRequest\n        }>\n      ): Promise<TokenResponse>;\n  \n      /**\n      * Issue a shopper token (JWT).\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type TokenResponse otherwise.\n      * \n      */\n      getPasswordLessAccessToken<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: PasswordLessLoginTokenRequest\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : TokenResponse>;\n  \n      /**\n      * Issue a shopper token (JWT).\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type TokenResponse otherwise.\n      * \n      */\n      async getPasswordLessAccessToken(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: PasswordLessLoginTokenRequest\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | TokenResponse> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperLoginPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperLoginQueryParameters & { [key in `c_${string}`]: any } = {};\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getPasswordLessAccessToken: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/oauth2/passwordless/token\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/x-www-form-urlencoded\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | TokenResponse;\n      }\n  \n      /**\n      * Invalidate the refresh token. A basic auth header with Base64-encoded `clientId:secret` is required in the Authorization header, and the refresh token to be revoked is required in the body.\n      *\n      * If you would like to get a raw Response object use the other revokeToken function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type TokenResponse.\n      * \n      */\n      revokeToken(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: TokenActionRequest\n        }>\n      ): Promise<TokenResponse>;\n  \n      /**\n      * Invalidate the refresh token. A basic auth header with Base64-encoded `clientId:secret` is required in the Authorization header, and the refresh token to be revoked is required in the body.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type TokenResponse otherwise.\n      * \n      */\n      revokeToken<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: TokenActionRequest\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : TokenResponse>;\n  \n      /**\n      * Invalidate the refresh token. A basic auth header with Base64-encoded `clientId:secret` is required in the Authorization header, and the refresh token to be revoked is required in the body.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type TokenResponse otherwise.\n      * \n      */\n      async revokeToken(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: TokenActionRequest\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | TokenResponse> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperLoginPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperLoginQueryParameters & { [key in `c_${string}`]: any } = {};\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for revokeToken: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/oauth2/revoke\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/x-www-form-urlencoded\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | TokenResponse;\n      }\n  \n      /**\n      * Returns the token properties. A basic auth header with Base64-encoded `clientId:secret` is required in the Authorization header, as well as an access token or refresh token. Use `token_type_hint` to help identify the token.\n      *\n      * If you would like to get a raw Response object use the other introspectToken function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type Object.\n      * \n      */\n      introspectToken(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: TokenActionRequest\n        }>\n      ): Promise<Object>;\n  \n      /**\n      * Returns the token properties. A basic auth header with Base64-encoded `clientId:secret` is required in the Authorization header, as well as an access token or refresh token. Use `token_type_hint` to help identify the token.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type Object otherwise.\n      * \n      */\n      introspectToken<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: TokenActionRequest\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : Object>;\n  \n      /**\n      * Returns the token properties. A basic auth header with Base64-encoded `clientId:secret` is required in the Authorization header, as well as an access token or refresh token. Use `token_type_hint` to help identify the token.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type Object otherwise.\n      * \n      */\n      async introspectToken(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: TokenActionRequest\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | Object> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperLoginPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperLoginQueryParameters & { [key in `c_${string}`]: any } = {};\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for introspectToken: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/oauth2/introspect\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/x-www-form-urlencoded\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | Object;\n      }\n  \n      /**\n      * Returns a JSON listing of claims about the currently authenticated user.\n      *\n      * If you would like to get a raw Response object use the other getUserInfo function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param channel_id - Used when getting user information for a SFCC login. For an ECOM customer, this is angalous to the site ID. Required when getting user information for an ECOM customer.\n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type Object.\n      * \n      */\n      getUserInfo(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            channel_id?: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<Object>;\n  \n      /**\n      * Returns a JSON listing of claims about the currently authenticated user.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param channel_id - Used when getting user information for a SFCC login. For an ECOM customer, this is angalous to the site ID. Required when getting user information for an ECOM customer.\n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type Object otherwise.\n      * \n      */\n      getUserInfo<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            channel_id?: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : Object>;\n  \n      /**\n      * Returns a JSON listing of claims about the currently authenticated user.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param channel_id - Used when getting user information for a SFCC login. For an ECOM customer, this is angalous to the site ID. Required when getting user information for an ECOM customer.\n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type Object otherwise.\n      * \n      */\n      async getUserInfo(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            channel_id?: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | Object> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperLoginPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperLoginQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"channel_id\"] !== undefined) {\n          queryParams[\"channel_id\"] = optionParams[\"channel_id\"];\n        } else if (configParams[\"channel_id\"] !== undefined) {\n          queryParams[\"channel_id\"] = configParams[\"channel_id\"];\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getUserInfo: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/oauth2/userinfo\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"GET\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | Object;\n      }\n  \n      /**\n      * Returns a JSON listing of the OpenID/OAuth endpoints, supported scopes and claims, public keys used to sign the tokens, and other details.\n  \n  For performance purposes, the `/jwks` endpoint is rate limited to 25 call per minute.\n  \n      *\n      * If you would like to get a raw Response object use the other getWellknownOpenidConfiguration function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type Object.\n      * \n      */\n      getWellknownOpenidConfiguration(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<Object>;\n  \n      /**\n      * Returns a JSON listing of the OpenID/OAuth endpoints, supported scopes and claims, public keys used to sign the tokens, and other details.\n  \n  For performance purposes, the `/jwks` endpoint is rate limited to 25 call per minute.\n  \n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type Object otherwise.\n      * \n      */\n      getWellknownOpenidConfiguration<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : Object>;\n  \n      /**\n      * Returns a JSON listing of the OpenID/OAuth endpoints, supported scopes and claims, public keys used to sign the tokens, and other details.\n  \n  For performance purposes, the `/jwks` endpoint is rate limited to 25 call per minute.\n  \n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type Object otherwise.\n      * \n      */\n      async getWellknownOpenidConfiguration(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | Object> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperLoginPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperLoginQueryParameters & { [key in `c_${string}`]: any } = {};\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getWellknownOpenidConfiguration: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/oauth2/.well-known/openid-configuration\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"GET\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | Object;\n      }\n  \n      /**\n      * Returns a JSON Web Key Set (JWKS) containing the current, past, and future public keys. The key set enables clients to validate the Shopper JSON Web Token (JWT) issued by SLAS.\n  \n  For performance purposes, the `/jwks` endpoint is rate limited to 25 call per minute.\n  \n      *\n      * If you would like to get a raw Response object use the other getJwksUri function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type Object.\n      * \n      */\n      getJwksUri(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<Object>;\n  \n      /**\n      * Returns a JSON Web Key Set (JWKS) containing the current, past, and future public keys. The key set enables clients to validate the Shopper JSON Web Token (JWT) issued by SLAS.\n  \n  For performance purposes, the `/jwks` endpoint is rate limited to 25 call per minute.\n  \n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type Object otherwise.\n      * \n      */\n      getJwksUri<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : Object>;\n  \n      /**\n      * Returns a JSON Web Key Set (JWKS) containing the current, past, and future public keys. The key set enables clients to validate the Shopper JSON Web Token (JWT) issued by SLAS.\n  \n  For performance purposes, the `/jwks` endpoint is rate limited to 25 call per minute.\n  \n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type Object otherwise.\n      * \n      */\n      async getJwksUri(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | Object> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperLoginPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperLoginQueryParameters & { [key in `c_${string}`]: any } = {};\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getJwksUri: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/oauth2/jwks\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"GET\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | Object;\n      }\n}\n"],"mappings":"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","names":[]}