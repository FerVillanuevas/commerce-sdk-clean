{"version":3,"sources":["../../src/responseError.ts","../../src/helpers/environment.ts","../../src/helpers/fetchHelper.ts"],"sourcesContent":["/*\n * Copyright (c) 2022, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * Extends the Error class with the the error being a combination of status code\n * and text retrieved from the response.\n *\n * @class ResponseError\n * @extends Error\n */\nexport default class ResponseError extends Error {\n  constructor(public response: Response) {\n    super(`${response.status} ${response.statusText}`);\n  }\n}\n","/*\n * Copyright (c) 2023, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\nimport type { FetchFunction } from \"../clientConfig\";\n\n/*\n * Copyright (c) 2022, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\nexport const isBrowser =\n  typeof window === \"object\" && typeof window.document === \"object\";\n\nexport const globalObject = isBrowser ? window : globalThis;\n\nexport const hasFetchAvailable = typeof globalObject.fetch === \"function\";\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\nexport const fetch: FetchFunction = (() => {\n  return globalObject.fetch;\n})();\n","/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\nimport { BaseUriParameters } from '.';\nimport type { FetchOptions } from '../clientConfig';\nimport { ClientConfigInit } from '../clientConfig';\nimport ResponseError from '../responseError';\nimport { fetch } from './environment';\n\n/**\n * A wrapper function around fetch designed for making requests using the SDK\n * @param url - The url of the resource that you wish to fetch\n * @param options? - An object containing any custom settings you want to apply to the request\n * @param options.method? - The request HTTP operation. 'GET' is the default if no method is provided.\n * @param options.headers? - Headers that are added to the request. Authorization header should be in this argument or in the clientConfig.headers\n * @param options.body? - Body that is used for the request\n * @param clientConfig? - Client Configuration object used by the SDK with properties that can affect the fetch call\n * @param clientConfig.headers? - Additional headers that are added to the request. Authorization header should be in this argument or in the options?.headers. options?.headers will override any duplicate properties.\n * @param clientConfig.fetchOptions? - fetchOptions that are passed onto the fetch request\n * @param clientConfig.throwOnBadResponse? - flag that when set true will throw a response error if the fetch request fails\n * @param rawResponse? - Flag to return the raw response from the fetch call. True for raw response object, false for the data from the response\n * @returns Raw response or data from response based on rawResponse argument from fetch call\n */\n// eslint-disable-next-line import/prefer-default-export\nexport const doFetch = async <Params extends BaseUriParameters>(\n  url: string,\n  options?: {\n    method?: string;\n    headers?: {\n      authorization?: string;\n    } & {[key: string]: string};\n    body?: BodyInit | globalThis.BodyInit | unknown;\n  },\n  clientConfig?: ClientConfigInit<Params>,\n  rawResponse?: boolean\n): Promise<Response | unknown> => {\n  const headers: Record<string, string> = {\n    ...clientConfig?.headers,\n    ...options?.headers,\n  };\n\n  const requestOptions: FetchOptions = {\n    ...clientConfig?.fetchOptions,\n    headers,\n    body: options?.body as\n      | (BodyInit & (globalThis.BodyInit | null))\n      | undefined,\n    method: options?.method ?? 'GET',\n  };\n\n  const response = await fetch(url, requestOptions);\n  if (rawResponse) {\n    return response;\n  }\n  if (\n    clientConfig?.throwOnBadResponse &&\n    !response.ok &&\n    response.status !== 304\n  ) {\n    throw new ResponseError(response);\n  } else {\n    const text = await response.text();\n    // It's ideal to get \"{}\" for an empty response body, but we won't throw if it's truly empty\n    return (text ? JSON.parse(text) : {}) as unknown | Response;\n  }\n};\n"],"mappings":";AAcA,IAAqB,gBAArB,cAA2C,MAAM;AAAA,EAC/C,YAAmB,UAAoB;AACrC,UAAM,GAAG,SAAS,MAAM,IAAI,SAAS,UAAU,EAAE;AADhC;AAAA,EAEnB;AACF;;;ACJO,IAAM,YACX,OAAO,WAAW,YAAY,OAAO,OAAO,aAAa;AAEpD,IAAM,eAAe,YAAY,SAAS;AAE1C,IAAM,oBAAoB,OAAO,aAAa,UAAU;AAGxD,IAAM,SAAwB,MAAM;AACzC,SAAO,aAAa;AACtB,GAAG;;;ACGI,IAAM,UAAU,OACrB,KACA,SAOA,cACA,gBACgC;AAChC,QAAM,UAAkC;AAAA,IACtC,GAAG,cAAc;AAAA,IACjB,GAAG,SAAS;AAAA,EACd;AAEA,QAAM,iBAA+B;AAAA,IACnC,GAAG,cAAc;AAAA,IACjB;AAAA,IACA,MAAM,SAAS;AAAA,IAGf,QAAQ,SAAS,UAAU;AAAA,EAC7B;AAEA,QAAM,WAAW,MAAM,MAAM,KAAK,cAAc;AAChD,MAAI,aAAa;AACf,WAAO;AAAA,EACT;AACA,MACE,cAAc,sBACd,CAAC,SAAS,MACV,SAAS,WAAW,KACpB;AACA,UAAM,IAAI,cAAc,QAAQ;AAAA,EAClC,OAAO;AACL,UAAM,OAAO,MAAM,SAAS,KAAK;AAEjC,WAAQ,OAAO,KAAK,MAAM,IAAI,IAAI,CAAC;AAAA,EACrC;AACF;","names":[]}