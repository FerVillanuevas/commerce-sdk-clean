{"version":3,"sources":["../src/shopperGiftCertificates.ts","../src/clientConfig.ts","../src/helpers/environment.ts","../src/responseError.ts","../src/helpers/fetchHelper.ts","../src/templateUrl.ts","../src/version.ts"],"sourcesContent":["import ClientConfig, { ClientConfigInit } from \"./clientConfig\";\n// Must not import from ./helpers/index to avoid circular dependency via ShopperLogin\nimport { isBrowser } from \"./helpers/environment\";\nimport { doFetch } from \"./helpers/fetchHelper\";\nimport type {\n  BaseUriParameters,\n  CompositeParameters,\n  RequireParametersUnlessAllAreOptional\n} from \"./helpers/types\";\nimport TemplateURL from \"./templateUrl\";\nimport { USER_AGENT_HEADER, USER_AGENT_VALUE } from \"./version\";\n\nexport type GiftCertificate = {\n  amount: number;\n  balance: number;\n  description?: string;\n  enabled: boolean;\n  maskedGiftCertificateCode: string;\n  merchantId: string;\n  message?: string;\n  recipientEmail: string;\n  recipientName: string;\n  senderName: string;\n  status: string;\n} & { [key: string]: any }\n\n  export type GiftCertificateRequest = {\n  giftCertificateCode: string;\n}\n  type NotFound = { [key: string]: any }\nexport type ErrorResponse = {\n  type: string;\n  title?: string;\n  detail?: string;\n  instance?: string;\n} & { [key: string]: any }\n\n  export type ChangeControlled = {\n  creationDate?: any;\n  modificationDate?: any;\n  createdBy?: string;\n  lastModifiedBy?: string;\n} & { [key: string]: any }\n\n  type DateRangeFilter = { [key: string]: any }\ntype EtagResponse = { [key: string]: any }\ntype IntegerRangeFilter = { [key: string]: any }\ntype RateLimited3 = { [key: string]: any }\ntype SyncCreated = { [key: string]: any }\ntype DateConditionalRequest = { [key: string]: any }\ntype RateLimited5 = { [key: string]: any }\ntype EtagConditionalRequest = { [key: string]: any }\ntype AsyncCreated = { [key: string]: any }\ntype RateLimited = { [key: string]: any }\ntype RateLimited2 = { [key: string]: any }\ntype OffsetPaginated = { [key: string]: any }\ntype RangeFilter = { [key: string]: any }\ntype RateLimited4 = { [key: string]: any }\ntype NumericRangeFilter = { [key: string]: any }\ntype DatetimeRangeFilter = { [key: string]: any }\nexport type ChangeControlledDataType = {\n  creationDate?: any;\n  modificationDate?: any;\n  createdBy?: string;\n  lastModifiedBy?: string;\n} & { [key: string]: any }\n\n  export type Error = {\n  type: string;\n  title?: string;\n  detail?: string;\n  instance?: string;\n} & { [key: string]: any }\n\n  export type Money = {\n  currencyMnemonic?: string;\n  value?: number;\n} & { [key: string]: any }\n\n  export type SimpleSearchResult = {\n  limit: number;\n  hits?: Array<object>;\n  offset: any;\n  total: any;\n} & { [key: string]: any }\n\n  export type SearchRequest = {\n  limit?: number;\n  query: Query;\n  sorts?: Array<Sort>;\n  offset?: any;\n} & { [key: string]: any }\n\n  export type PropertyDefinition = {\n  defaultValue?: PropertyValueDefinition;\n  id?: string;\n  name: L10nString;\n  description: L10nString;\n  key?: boolean;\n  localizable?: boolean;\n  mandatory?: boolean;\n  max?: number;\n  minLength?: number;\n  min?: number;\n  multiValueType?: boolean;\n  regularExpression?: string;\n  scale?: number;\n  searchable?: boolean;\n  siteSpecific?: boolean;\n  system?: boolean;\n  unit?: L10nString;\n  possibleValues?: Array<PropertyValueDefinition>;\n  type: string;\n  visible?: boolean;\n} & { [key: string]: any }\n\n  export type LocalizedString = {\n} & { [key: string]: any }\n\n  export type PaginatedSearchResult = {\n  query: Query;\n  sorts?: Array<Sort>;\n  limit: number;\n  hits?: Array<object>;\n  offset: any;\n  total: any;\n} & { [key: string]: any }\n\n  export type ClosedObject = {\n} & { [key: string]: any }\n\n  export type OpenObject = {\n} & { [key: string]: any }\n\n  type QueryParamsLimit = { [key: string]: any }\ntype QueryParamsOffset = { [key: string]: any }\ntype SiteSpecific = { [key: string]: any }\ntype Selectable = { [key: string]: any }\nexport type NoPropertiesAllowed = {\n}\n  export type SpecifiedPropertiesAllowed = {\n} & { [key: string]: any }\n\n  export type BoolFilter = {\n  filters?: Array<Filter>;\n  operator: string;\n} & { [key: string]: any }\n\n  export type PaginatedSearchResultBase = {\n  query: Query;\n  sorts?: Array<Sort>;\n  limit: number;\n  hits?: Array<object>;\n  offset: any;\n  total: any;\n} & { [key: string]: any }\n\n  export type MatchAllQuery = {\n} & { [key: string]: any }\n\n  export type FilteredQuery = {\n  filter: Filter;\n  query: Query;\n} & { [key: string]: any }\n\n  export type QueryFilter = {\n  query: Query;\n} & { [key: string]: any }\n\n  export type Query = {\n  boolQuery?: BoolQuery;\n  filteredQuery?: FilteredQuery;\n  matchAllQuery?: MatchAllQuery;\n  nestedQuery?: NestedQuery;\n  termQuery?: TermQuery;\n  textQuery?: TextQuery;\n} & { [key: string]: any }\n\n  export type TermQuery = {\n  fields: Array<string>;\n  operator: string;\n  values?: Array<any>;\n} & { [key: string]: any }\n\n  export type TermFilter = {\n  field: string;\n  operator: string;\n  values?: Array<any>;\n} & { [key: string]: any }\n\n  export type TextQuery = {\n  fields: Array<string>;\n  searchPhrase: string;\n} & { [key: string]: any }\n\n  export type Range2Filter = {\n  filterMode?: string;\n  fromField: string;\n  fromInclusive?: boolean;\n  fromValue?: any;\n  toField: string;\n  toInclusive?: boolean;\n  toValue?: any;\n} & { [key: string]: any }\n\n  export type BoolQuery = {\n  must?: Array<Query>;\n  mustNot?: Array<Query>;\n  should?: Array<Query>;\n} & { [key: string]: any }\n\n  export type SimpleSearchResultBase = {\n  limit: number;\n  hits?: Array<object>;\n  offset: any;\n  total: any;\n} & { [key: string]: any }\n\n  export type NestedQuery = {\n  path: string;\n  query: Query;\n  scoreMode?: string;\n} & { [key: string]: any }\n\n  export type Filter = {\n  boolFilter?: BoolFilter;\n  queryFilter?: QueryFilter;\n  range2Filter?: Range2Filter;\n  rangeFilter?: RangeFilter;\n  termFilter?: TermFilter;\n} & { [key: string]: any }\n\n  export type Sort = {\n  field: string;\n  sortOrder?: string;\n} & { [key: string]: any }\n\n  export type SearchRequestBase = {\n  limit?: number;\n  query: Query;\n  sorts?: Array<Sort>;\n  offset?: any;\n} & { [key: string]: any }\n\n  export type MoneyMnemonic = {\n  currencyMnemonic?: string;\n  value?: number;\n} & { [key: string]: any }\n\n  export type L10nString = {\n} & { [key: string]: any }\n\n  export type AttributeDefinition = {\n  defaultValue?: PropertyValueDefinition;\n  id?: string;\n  name: L10nString;\n  description: L10nString;\n  key?: boolean;\n  localizable?: boolean;\n  mandatory?: boolean;\n  max?: number;\n  minLength?: number;\n  min?: number;\n  multiValueType?: boolean;\n  regularExpression?: string;\n  scale?: number;\n  searchable?: boolean;\n  siteSpecific?: boolean;\n  system?: boolean;\n  unit?: L10nString;\n  possibleValues?: Array<PropertyValueDefinition>;\n  type: string;\n  visible?: boolean;\n}\n  export type PropertyValueDefinition = {\n  description: L10nString;\n  displayValue: L10nString;\n  id: string;\n  position?: number;\n  value: string;\n}\n  \n/**\n * All path parameters that are used by at least one ShopperGiftCertificates method.\n */\nexport type ShopperGiftCertificatesPathParameters = {\n  organizationId?: string;\n}\n/**\n * All query parameters that are used by at least one ShopperGiftCertificates method.\n */\nexport type ShopperGiftCertificatesQueryParameters = {\n  siteId?: string;\n}\n\n/**\n * All parameters that are used by ShopperGiftCertificates.\n */\nexport type ShopperGiftCertificatesParameters = ShopperGiftCertificatesPathParameters & BaseUriParameters & ShopperGiftCertificatesQueryParameters;\n\n/**\n* [Shopper Gift Certificates](https://developer.salesforce.com/docs/commerce/commerce-api/references?meta=shopper-gift-certificates:Summary)\n* ==================================\n*\n* *Obtain details about a gift certificate.*<br />\n*\n* Simple example:\n*\n* ```typescript\n*   import { ShopperGiftCertificates } from \"commerce-sdk-isomorphic\";\n*\n*   const clientConfig = {\n*     parameters: {\n*       clientId: \"XXXXXX\",\n*       organizationId: \"XXXX\",\n*       shortCode: \"XXX\",\n*       siteId: \"XX\"\n*     }\n*   };\n*   const shopperGiftCertificatesClient = new ShopperGiftCertificates(clientConfig);\n* ```\n*\n* <span style=\"font-size:.7em; display:block; text-align: right\">\n* API Version: 1.0.17<br />\n* Last Updated: <br />\n* </span>\n* \n*\n*/\nexport class ShopperGiftCertificates<ConfigParameters extends ShopperGiftCertificatesParameters & Record<string, unknown>> {\n  // baseUri is not required on ClientConfig, but we know that we provide one in the class constructor\n  public clientConfig: ClientConfig<ConfigParameters> & { baseUri: string };\n\n  static readonly defaultBaseUri = \"https://{shortCode}.api.commercecloud.salesforce.com/pricing/shopper-gift-certificates/{version}\";\n\n  static readonly apiPaths = {\n    getGiftCertificate: \"/organizations/{organizationId}/gift-certificate\",\n  };\n\n  constructor(config: ClientConfigInit<ConfigParameters>) {\n    const cfg = {...config}\n    if (!cfg.baseUri) cfg.baseUri = new.target.defaultBaseUri;\n    // Type assertion is safe because ^^^\n    this.clientConfig = new ClientConfig(cfg) as ClientConfig<ConfigParameters> & { baseUri: string };\n  }\n\n  static readonly paramKeys = {\n    getGiftCertificate: [\n      'organizationId',\n      'siteId',\n    ],\n    getGiftCertificateRequired: [\n      'organizationId',\n      'siteId',\n    ],\n  } as const;\n  \n      /**\n      * Action to retrieve an existing gift certificate.\n      *\n      * If you would like to get a raw Response object use the other getGiftCertificate function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - An identifier for the organization the request is being made by.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type GiftCertificate.\n      * \n      */\n      getGiftCertificate(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: GiftCertificateRequest\n        }>\n      ): Promise<GiftCertificate>;\n  \n      /**\n      * Action to retrieve an existing gift certificate.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - An identifier for the organization the request is being made by.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type GiftCertificate otherwise.\n      * \n      */\n      getGiftCertificate<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: GiftCertificateRequest\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : GiftCertificate>;\n  \n      /**\n      * Action to retrieve an existing gift certificate.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - An identifier for the organization the request is being made by.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type GiftCertificate otherwise.\n      * \n      */\n      async getGiftCertificate(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: GiftCertificateRequest\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | GiftCertificate> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperGiftCertificatesPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperGiftCertificatesQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getGiftCertificate: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/gift-certificate\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/json\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | GiftCertificate;\n      }\n}\n","/*\n * Copyright (c) 2021, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\nimport type { BaseUriParameters } from './helpers/types';\n\n/**\n * Alias for `RequestInit` from TypeScript's DOM lib, to more clearly differentiate\n * it from the `RequestInit` provided by node-fetch.\n */\ntype BrowserRequestInit = RequestInit;\n/**\n * Any properties supported in either the browser or node are accepted.\n * Using the right properties in the right context is left to the user.\n */\nexport type FetchOptions =  BrowserRequestInit;\n\n/**\n * Base options that can be passed to the `ClientConfig` class.\n */\nexport interface ClientConfigInit<Params extends BaseUriParameters> {\n  baseUri?: string;\n  proxy?: string;\n  headers?: {[key: string]: string};\n  parameters: Params;\n  fetchOptions?: FetchOptions;\n  transformRequest?: (\n    data: unknown,\n    headers: {[key: string]: string}\n  ) => Required<FetchOptions>['body'];\n  throwOnBadResponse?: boolean;\n}\n\nexport type FetchFunction = (\n  input: RequestInfo,\n  init?: FetchOptions | undefined\n) => Promise<Response>;\n\n/**\n * Configuration parameters common to Commerce SDK clients\n */\nexport default class ClientConfig<Params extends BaseUriParameters>\n  implements ClientConfigInit<Params>\n{\n  public baseUri?: string;\n\n  public proxy?: string;\n\n  public headers: {[key: string]: string};\n\n  public parameters: Params;\n\n  public fetchOptions: FetchOptions;\n\n  public transformRequest: NonNullable<\n    ClientConfigInit<Params>['transformRequest']\n  >;\n\n  public throwOnBadResponse: boolean;\n\n  constructor(config: ClientConfigInit<Params>) {\n    this.headers = {...config.headers};\n    this.parameters = {...config.parameters};\n    // shortCode is required in the type, but we still check that it is present for the JS users\n    if (!this.parameters.shortCode) {\n      throw new Error('Missing required parameter: shortCode');\n    }\n    this.fetchOptions = {\n      credentials: 'omit',\n      ...config.fetchOptions,\n    };\n    this.transformRequest =\n      config.transformRequest || ClientConfig.defaults.transformRequest;\n\n    // Optional properties\n    if (config.baseUri) {\n      this.baseUri = config.baseUri;\n    }\n    if (config.proxy) {\n      this.proxy = config.proxy;\n    }\n    this.throwOnBadResponse = !!config.throwOnBadResponse;\n  }\n\n  static readonly defaults: Pick<\n    Required<ClientConfigInit<never>>,\n    'transformRequest'\n  > = {\n    /**\n     * If the `Content-Type` header is `application/json`, the data is converted to a JSON string.\n     * If the `Content-Type` header is `application/x-www-form-urlencoded`, the data is converted to\n     * a `URLSearchParams` object.\n     * In all other cases, the data is returned unmodified.\n     * @param data - Data to transform\n     * @returns A payload appropriate for the specified `Content-Type` header\n     */\n    transformRequest(data, headers) {\n      switch (headers['Content-Type']) {\n        case 'application/json': {\n          return JSON.stringify(data);\n        }\n        case 'application/x-www-form-urlencoded': {\n          // Only SLAS uses this content type, and all of their payloads are Record<string, string>.\n          // Future APIs are unlikely to use this content type. Additionally, URLSearchParams\n          // actually accepts Record<string, unknown> and converts the values to strings.\n          // Therefore, this type assertion isn't *strictly* safe, but is unlikely to cause issues.\n          return new URLSearchParams(data as Record<string, string>);\n        }\n        default: {\n          // This type assertion isn't safe. However, this default case will not occur with the\n          // currently known APIs, as they all use a Content-Type already specified. Rather than\n          // throwing in this case, we return the data unmodified, to be more flexible in case there\n          // are different content types in future APIs.\n          return data as Required<FetchOptions>['body'];\n        }\n      }\n    },\n  };\n}\n","/*\n * Copyright (c) 2023, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\nimport type { FetchFunction } from \"../clientConfig\";\n\n/*\n * Copyright (c) 2022, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\nexport const isBrowser =\n  typeof window === \"object\" && typeof window.document === \"object\";\n\nexport const globalObject = isBrowser ? window : globalThis;\n\nexport const hasFetchAvailable = typeof globalObject.fetch === \"function\";\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\nexport const fetch: FetchFunction = (() => {\n  return globalObject.fetch;\n})();\n","/*\n * Copyright (c) 2022, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * Extends the Error class with the the error being a combination of status code\n * and text retrieved from the response.\n *\n * @class ResponseError\n * @extends Error\n */\nexport default class ResponseError extends Error {\n  constructor(public response: Response) {\n    super(`${response.status} ${response.statusText}`);\n  }\n}\n","/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\nimport { BaseUriParameters } from '.';\nimport type { FetchOptions } from '../clientConfig';\nimport { ClientConfigInit } from '../clientConfig';\nimport ResponseError from '../responseError';\nimport { fetch } from './environment';\n\n/**\n * A wrapper function around fetch designed for making requests using the SDK\n * @param url - The url of the resource that you wish to fetch\n * @param options? - An object containing any custom settings you want to apply to the request\n * @param options.method? - The request HTTP operation. 'GET' is the default if no method is provided.\n * @param options.headers? - Headers that are added to the request. Authorization header should be in this argument or in the clientConfig.headers\n * @param options.body? - Body that is used for the request\n * @param clientConfig? - Client Configuration object used by the SDK with properties that can affect the fetch call\n * @param clientConfig.headers? - Additional headers that are added to the request. Authorization header should be in this argument or in the options?.headers. options?.headers will override any duplicate properties.\n * @param clientConfig.fetchOptions? - fetchOptions that are passed onto the fetch request\n * @param clientConfig.throwOnBadResponse? - flag that when set true will throw a response error if the fetch request fails\n * @param rawResponse? - Flag to return the raw response from the fetch call. True for raw response object, false for the data from the response\n * @returns Raw response or data from response based on rawResponse argument from fetch call\n */\n// eslint-disable-next-line import/prefer-default-export\nexport const doFetch = async <Params extends BaseUriParameters>(\n  url: string,\n  options?: {\n    method?: string;\n    headers?: {\n      authorization?: string;\n    } & {[key: string]: string};\n    body?: BodyInit | globalThis.BodyInit | unknown;\n  },\n  clientConfig?: ClientConfigInit<Params>,\n  rawResponse?: boolean\n): Promise<Response | unknown> => {\n  const headers: Record<string, string> = {\n    ...clientConfig?.headers,\n    ...options?.headers,\n  };\n\n  const requestOptions: FetchOptions = {\n    ...clientConfig?.fetchOptions,\n    headers,\n    body: options?.body as\n      | (BodyInit & (globalThis.BodyInit | null))\n      | undefined,\n    method: options?.method ?? 'GET',\n  };\n\n  const response = await fetch(url, requestOptions);\n  if (rawResponse) {\n    return response;\n  }\n  if (\n    clientConfig?.throwOnBadResponse &&\n    !response.ok &&\n    response.status !== 304\n  ) {\n    throw new ResponseError(response);\n  } else {\n    const text = await response.text();\n    // It's ideal to get \"{}\" for an empty response body, but we won't throw if it's truly empty\n    return (text ? JSON.parse(text) : {}) as unknown | Response;\n  }\n};\n","/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\nimport type {PathParameters, QueryParameters} from './helpers/types';\n\nexport default class TemplateURL extends URL {\n  /**\n   * @param url -\n   * @param base -\n   */\n  constructor(\n    url: string,\n    base: string,\n    parameters?: {\n      pathParams?: PathParameters;\n      queryParams?: QueryParameters;\n      origin?: string;\n    }\n  ) {\n    super(\n      TemplateURL.renderTemplateUri(\n        `${base}/${url}`.replace(/\\/\\/+/g, '/'),\n        parameters?.pathParams\n      )\n    );\n    this.addQueryParams(parameters?.queryParams);\n    if (parameters?.origin) {\n      this.replaceOrigin(parameters?.origin);\n    }\n  }\n\n  /**\n   * Replace the origin (protocol/host) portion of the URL with a new origin.\n   * The path portion is retained and concatenated with any path included in the\n   * new origin. Thee primary use of this function is to use a proxy.\n   *\n   * @param newOriginString - The new origin to substitute (ex: https://example.com)\n   */\n  replaceOrigin(newOriginString: string): void {\n    const newOriginUrl = new URL(newOriginString);\n    this.protocol = newOriginUrl.protocol;\n    this.host = newOriginUrl.host;\n    this.pathname = `${newOriginUrl.pathname}/${this.pathname}`.replace(\n      /\\/\\/+/g,\n      '/'\n    );\n  }\n\n  /**\n   * Add append an object literal of query parameters to the URL object. SCAPI expects\n   * Arrays to be comma separated where \\{ a: [\"1\", \"2\"] \\} becomes ?a=1,2.\n   * The 'refine' query parameter is an exception, where SCAPI expects the the \"repeat\"\n   * convention where \\{ refine: [\"1\", \"2\"] \\} becomes \"?refine=1&refine=2\"\n   */\n  addQueryParams(queryParams?: QueryParameters): void {\n    if (queryParams) {\n      Object.keys(queryParams).forEach(key => {\n        const param = queryParams[key];\n        if (Array.isArray(param)) {\n          if (key === 'refine') {\n            for (let i = 0; i < param.length; i += 1) {\n              this.searchParams.append(key, String(param[i]));\n            }\n          } else {\n            this.searchParams.append(key, param.join());\n          }\n        } else {\n          this.searchParams.append(key, String(param));\n        }\n      });\n    }\n  }\n\n  /**\n   * Replace bracketed URL template parameters with values from parameters object\n   *\n   * @param template - The URL template string to make substitutions in\n   * @param parameters - The object literal that provides the values to substitute\n   *\n   * @returns String URL with substitutions made\n   */\n  static renderTemplateUri(\n    template: string,\n    parameters?: PathParameters\n  ): string {\n    return parameters\n      ? template.replace(\n          /\\{([^\\}]+)\\}/g /* eslint-disable-line no-useless-escape */,\n          (match, param: string) => String(parameters[param])\n        )\n      : template;\n  }\n}\n","export const USER_AGENT_HEADER = \"user-agent\";\nexport const USER_AGENT_VALUE = \"commerce-sdk-isomorphic@3.1.1\";\n"],"mappings":"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","names":[]}