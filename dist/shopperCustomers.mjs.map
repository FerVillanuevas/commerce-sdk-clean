{"version":3,"sources":["../src/clientConfig.ts","../src/helpers/environment.ts","../src/responseError.ts","../src/helpers/fetchHelper.ts","../src/templateUrl.ts","../src/version.ts","../src/shopperCustomers.ts"],"sourcesContent":["/*\n * Copyright (c) 2021, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\nimport type { BaseUriParameters } from './helpers/types';\n\n/**\n * Alias for `RequestInit` from TypeScript's DOM lib, to more clearly differentiate\n * it from the `RequestInit` provided by node-fetch.\n */\ntype BrowserRequestInit = RequestInit;\n/**\n * Any properties supported in either the browser or node are accepted.\n * Using the right properties in the right context is left to the user.\n */\nexport type FetchOptions =  BrowserRequestInit;\n\n/**\n * Base options that can be passed to the `ClientConfig` class.\n */\nexport interface ClientConfigInit<Params extends BaseUriParameters> {\n  baseUri?: string;\n  proxy?: string;\n  headers?: {[key: string]: string};\n  parameters: Params;\n  fetchOptions?: FetchOptions;\n  transformRequest?: (\n    data: unknown,\n    headers: {[key: string]: string}\n  ) => Required<FetchOptions>['body'];\n  throwOnBadResponse?: boolean;\n}\n\nexport type FetchFunction = (\n  input: RequestInfo,\n  init?: FetchOptions | undefined\n) => Promise<Response>;\n\n/**\n * Configuration parameters common to Commerce SDK clients\n */\nexport default class ClientConfig<Params extends BaseUriParameters>\n  implements ClientConfigInit<Params>\n{\n  public baseUri?: string;\n\n  public proxy?: string;\n\n  public headers: {[key: string]: string};\n\n  public parameters: Params;\n\n  public fetchOptions: FetchOptions;\n\n  public transformRequest: NonNullable<\n    ClientConfigInit<Params>['transformRequest']\n  >;\n\n  public throwOnBadResponse: boolean;\n\n  constructor(config: ClientConfigInit<Params>) {\n    this.headers = {...config.headers};\n    this.parameters = {...config.parameters};\n    // shortCode is required in the type, but we still check that it is present for the JS users\n    if (!this.parameters.shortCode) {\n      throw new Error('Missing required parameter: shortCode');\n    }\n    this.fetchOptions = {\n      credentials: 'omit',\n      ...config.fetchOptions,\n    };\n    this.transformRequest =\n      config.transformRequest || ClientConfig.defaults.transformRequest;\n\n    // Optional properties\n    if (config.baseUri) {\n      this.baseUri = config.baseUri;\n    }\n    if (config.proxy) {\n      this.proxy = config.proxy;\n    }\n    this.throwOnBadResponse = !!config.throwOnBadResponse;\n  }\n\n  static readonly defaults: Pick<\n    Required<ClientConfigInit<never>>,\n    'transformRequest'\n  > = {\n    /**\n     * If the `Content-Type` header is `application/json`, the data is converted to a JSON string.\n     * If the `Content-Type` header is `application/x-www-form-urlencoded`, the data is converted to\n     * a `URLSearchParams` object.\n     * In all other cases, the data is returned unmodified.\n     * @param data - Data to transform\n     * @returns A payload appropriate for the specified `Content-Type` header\n     */\n    transformRequest(data, headers) {\n      switch (headers['Content-Type']) {\n        case 'application/json': {\n          return JSON.stringify(data);\n        }\n        case 'application/x-www-form-urlencoded': {\n          // Only SLAS uses this content type, and all of their payloads are Record<string, string>.\n          // Future APIs are unlikely to use this content type. Additionally, URLSearchParams\n          // actually accepts Record<string, unknown> and converts the values to strings.\n          // Therefore, this type assertion isn't *strictly* safe, but is unlikely to cause issues.\n          return new URLSearchParams(data as Record<string, string>);\n        }\n        default: {\n          // This type assertion isn't safe. However, this default case will not occur with the\n          // currently known APIs, as they all use a Content-Type already specified. Rather than\n          // throwing in this case, we return the data unmodified, to be more flexible in case there\n          // are different content types in future APIs.\n          return data as Required<FetchOptions>['body'];\n        }\n      }\n    },\n  };\n}\n","/*\n * Copyright (c) 2023, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\nimport type { FetchFunction } from \"../clientConfig\";\n\n/*\n * Copyright (c) 2022, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\nexport const isBrowser =\n  typeof window === \"object\" && typeof window.document === \"object\";\n\nexport const globalObject = isBrowser ? window : globalThis;\n\nexport const hasFetchAvailable = typeof globalObject.fetch === \"function\";\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\nexport const fetch: FetchFunction = (() => {\n  return globalObject.fetch;\n})();\n","/*\n * Copyright (c) 2022, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * Extends the Error class with the the error being a combination of status code\n * and text retrieved from the response.\n *\n * @class ResponseError\n * @extends Error\n */\nexport default class ResponseError extends Error {\n  constructor(public response: Response) {\n    super(`${response.status} ${response.statusText}`);\n  }\n}\n","/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\nimport { BaseUriParameters } from '.';\nimport type { FetchOptions } from '../clientConfig';\nimport { ClientConfigInit } from '../clientConfig';\nimport ResponseError from '../responseError';\nimport { fetch } from './environment';\n\n/**\n * A wrapper function around fetch designed for making requests using the SDK\n * @param url - The url of the resource that you wish to fetch\n * @param options? - An object containing any custom settings you want to apply to the request\n * @param options.method? - The request HTTP operation. 'GET' is the default if no method is provided.\n * @param options.headers? - Headers that are added to the request. Authorization header should be in this argument or in the clientConfig.headers\n * @param options.body? - Body that is used for the request\n * @param clientConfig? - Client Configuration object used by the SDK with properties that can affect the fetch call\n * @param clientConfig.headers? - Additional headers that are added to the request. Authorization header should be in this argument or in the options?.headers. options?.headers will override any duplicate properties.\n * @param clientConfig.fetchOptions? - fetchOptions that are passed onto the fetch request\n * @param clientConfig.throwOnBadResponse? - flag that when set true will throw a response error if the fetch request fails\n * @param rawResponse? - Flag to return the raw response from the fetch call. True for raw response object, false for the data from the response\n * @returns Raw response or data from response based on rawResponse argument from fetch call\n */\n// eslint-disable-next-line import/prefer-default-export\nexport const doFetch = async <Params extends BaseUriParameters>(\n  url: string,\n  options?: {\n    method?: string;\n    headers?: {\n      authorization?: string;\n    } & {[key: string]: string};\n    body?: BodyInit | globalThis.BodyInit | unknown;\n  },\n  clientConfig?: ClientConfigInit<Params>,\n  rawResponse?: boolean\n): Promise<Response | unknown> => {\n  const headers: Record<string, string> = {\n    ...clientConfig?.headers,\n    ...options?.headers,\n  };\n\n  const requestOptions: FetchOptions = {\n    ...clientConfig?.fetchOptions,\n    headers,\n    body: options?.body as\n      | (BodyInit & (globalThis.BodyInit | null))\n      | undefined,\n    method: options?.method ?? 'GET',\n  };\n\n  const response = await fetch(url, requestOptions);\n  if (rawResponse) {\n    return response;\n  }\n  if (\n    clientConfig?.throwOnBadResponse &&\n    !response.ok &&\n    response.status !== 304\n  ) {\n    throw new ResponseError(response);\n  } else {\n    const text = await response.text();\n    // It's ideal to get \"{}\" for an empty response body, but we won't throw if it's truly empty\n    return (text ? JSON.parse(text) : {}) as unknown | Response;\n  }\n};\n","/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause\n */\nimport type {PathParameters, QueryParameters} from './helpers/types';\n\nexport default class TemplateURL extends URL {\n  /**\n   * @param url -\n   * @param base -\n   */\n  constructor(\n    url: string,\n    base: string,\n    parameters?: {\n      pathParams?: PathParameters;\n      queryParams?: QueryParameters;\n      origin?: string;\n    }\n  ) {\n    super(\n      TemplateURL.renderTemplateUri(\n        `${base}/${url}`.replace(/\\/\\/+/g, '/'),\n        parameters?.pathParams\n      )\n    );\n    this.addQueryParams(parameters?.queryParams);\n    if (parameters?.origin) {\n      this.replaceOrigin(parameters?.origin);\n    }\n  }\n\n  /**\n   * Replace the origin (protocol/host) portion of the URL with a new origin.\n   * The path portion is retained and concatenated with any path included in the\n   * new origin. Thee primary use of this function is to use a proxy.\n   *\n   * @param newOriginString - The new origin to substitute (ex: https://example.com)\n   */\n  replaceOrigin(newOriginString: string): void {\n    const newOriginUrl = new URL(newOriginString);\n    this.protocol = newOriginUrl.protocol;\n    this.host = newOriginUrl.host;\n    this.pathname = `${newOriginUrl.pathname}/${this.pathname}`.replace(\n      /\\/\\/+/g,\n      '/'\n    );\n  }\n\n  /**\n   * Add append an object literal of query parameters to the URL object. SCAPI expects\n   * Arrays to be comma separated where \\{ a: [\"1\", \"2\"] \\} becomes ?a=1,2.\n   * The 'refine' query parameter is an exception, where SCAPI expects the the \"repeat\"\n   * convention where \\{ refine: [\"1\", \"2\"] \\} becomes \"?refine=1&refine=2\"\n   */\n  addQueryParams(queryParams?: QueryParameters): void {\n    if (queryParams) {\n      Object.keys(queryParams).forEach(key => {\n        const param = queryParams[key];\n        if (Array.isArray(param)) {\n          if (key === 'refine') {\n            for (let i = 0; i < param.length; i += 1) {\n              this.searchParams.append(key, String(param[i]));\n            }\n          } else {\n            this.searchParams.append(key, param.join());\n          }\n        } else {\n          this.searchParams.append(key, String(param));\n        }\n      });\n    }\n  }\n\n  /**\n   * Replace bracketed URL template parameters with values from parameters object\n   *\n   * @param template - The URL template string to make substitutions in\n   * @param parameters - The object literal that provides the values to substitute\n   *\n   * @returns String URL with substitutions made\n   */\n  static renderTemplateUri(\n    template: string,\n    parameters?: PathParameters\n  ): string {\n    return parameters\n      ? template.replace(\n          /\\{([^\\}]+)\\}/g /* eslint-disable-line no-useless-escape */,\n          (match, param: string) => String(parameters[param])\n        )\n      : template;\n  }\n}\n","export const USER_AGENT_HEADER = \"user-agent\";\nexport const USER_AGENT_VALUE = \"commerce-sdk-isomorphic@3.1.1\";\n","import ClientConfig, { ClientConfigInit } from \"./clientConfig\";\n// Must not import from ./helpers/index to avoid circular dependency via ShopperLogin\nimport { isBrowser } from \"./helpers/environment\";\nimport { doFetch } from \"./helpers/fetchHelper\";\nimport type {\n  BaseUriParameters,\n  CompositeParameters,\n  RequireParametersUnlessAllAreOptional\n} from \"./helpers/types\";\nimport TemplateURL from \"./templateUrl\";\nimport { USER_AGENT_HEADER, USER_AGENT_VALUE } from \"./version\";\n\nexport type CustomerAddress = {\n  address1?: string;\n  address2?: string;\n  addressId: string;\n  city?: string;\n  companyName?: string;\n  countryCode: string;\n  creationDate?: any;\n  firstName?: string;\n  fullName?: string;\n  jobTitle?: string;\n  lastModified?: any;\n  lastName: string;\n  phone?: string;\n  postBox?: string;\n  postalCode?: string;\n  preferred?: boolean;\n  salutation?: string;\n  secondName?: string;\n  stateCode?: string;\n  suffix?: string;\n  suite?: string;\n  title?: string;\n} & { [key: string]: any }\n\n  export type CustomerProductListResult = {\n  limit: number;\n  data: Array<CustomerProductList>;\n  total: number;\n} & { [key: string]: any }\n\n  export type CustomerProductListItemPurchase = {\n  id: string;\n  orderNo: string;\n  productListItemId: string;\n  purchaserName: string;\n  quantity: number;\n} & { [key: string]: any }\n\n  export type OptionValue = {\n  default?: boolean;\n  id: string;\n  name?: string;\n  price?: number;\n} & { [key: string]: any }\n\n  export type Master = {\n  masterId: string;\n  orderable?: boolean;\n  price?: number;\n  priceMax?: number;\n  prices?: {\n} & { [key: string]: any }\n;\n} & { [key: string]: any }\n\n  export type OrderAddress = {\n  address1: string;\n  address2?: string;\n  city: string;\n  companyName?: string;\n  countryCode: string;\n  firstName: string;\n  fullName?: string;\n  id?: string;\n  jobTitle?: string;\n  lastName: string;\n  phone?: string;\n  postBox?: string;\n  postalCode: string;\n  salutation?: string;\n  secondName?: string;\n  stateCode?: string;\n  suffix?: string;\n  suite?: string;\n  title?: string;\n} & { [key: string]: any }\n\n  export type PublicProductListResult = {\n  limit: number;\n  data: Array<PublicProductListInfo>;\n  total: number;\n} & { [key: string]: any }\n\n  export type BasketsResult = {\n  baskets?: Array<Basket>;\n  total: number;\n} & { [key: string]: any }\n\n  export type TrustedSystemAuthRequest = {\n  clientId: string;\n  login: string;\n} & { [key: string]: any }\n\n  export type ResetPasswordRequest = {\n  resetToken: string;\n  login: string;\n  newPassword: string;\n} & { [key: string]: any }\n\n  export type PaymentCard = {\n  cardType: string;\n  creditCardExpired?: boolean;\n  creditCardToken?: string;\n  expirationMonth?: number;\n  expirationYear?: number;\n  holder?: string;\n  issueNumber?: string;\n  maskedNumber?: string;\n  numberLastDigits?: string;\n  validFromMonth?: number;\n  validFromYear?: number;\n} & { [key: string]: any }\n\n  export type ShippingItem = {\n  adjustedTax: number;\n  basePrice: number;\n  itemId: string;\n  itemText: string;\n  price: number;\n  priceAdjustments: Array<PriceAdjustment>;\n  priceAfterItemDiscount: number;\n  shipmentId: string;\n  tax: number;\n  taxBasis: number;\n  taxClassId: string;\n  taxRate: number;\n} & { [key: string]: any }\n\n  export type Discount = {\n  amount?: number;\n  percentage?: number;\n  priceBookId?: string;\n  type: string;\n} & { [key: string]: any }\n\n  export type ResetPasswordToken = {\n  login: string;\n  email: string;\n  resetToken: string;\n  expiresInMinutes: number;\n} & { [key: string]: any }\n\n  export type CouponItem = {\n  code: string;\n  couponItemId?: string;\n  statusCode?: string;\n  valid?: boolean;\n} & { [key: string]: any }\n\n  export type ShippingPromotion = {\n  calloutMsg: string;\n  promotionId: string;\n  promotionName: string;\n} & { [key: string]: any }\n\n  export type VariationAttribute = {\n  id: string;\n  name?: string;\n  values?: Array<VariationAttributeValue>;\n} & { [key: string]: any }\n\n  export type ProductListShippingAddress = {\n  addressId: string;\n  city?: string;\n  firstName?: string;\n  lastName?: string;\n} & { [key: string]: any }\n\n  export type ProductItem = {\n  adjustedTax?: number;\n  basePrice?: number;\n  bonusDiscountLineItemId?: string;\n  bonusProductLineItem?: boolean;\n  bundledProductItems?: Array<ProductItem>;\n  gift?: boolean;\n  giftMessage?: string;\n  inventoryId?: string;\n  itemId?: string;\n  itemText?: string;\n  optionItems?: Array<OptionItem>;\n  price?: number;\n  priceAdjustments?: Array<PriceAdjustment>;\n  priceAfterItemDiscount?: number;\n  priceAfterOrderDiscount?: number;\n  productId?: string;\n  productListItem?: ProductListItemReference;\n  productName?: string;\n  quantity: number;\n  shipmentId?: string;\n  shippingItemId?: string;\n  tax?: number;\n  taxBasis?: number;\n  taxClassId?: string;\n  taxRate?: number;\n} & { [key: string]: any }\n\n  export type CustomerProductListRegistrant = {\n  email: string;\n  firstName: string;\n  lastName: string;\n  role: string;\n} & { [key: string]: any }\n\n  export type PublicProductListInfo = {\n  description?: string;\n  id: string;\n  name?: string;\n  title: string;\n  type: string;\n} & { [key: string]: any }\n\n  export type CustomerPaymentCardRequest = {\n  cardType: string;\n  creditCardToken?: string;\n  expirationMonth: number;\n  expirationYear: number;\n  holder: string;\n  issueNumber: string;\n  number: string;\n  validFromMonth: number;\n  validFromYear: number;\n} & { [key: string]: any }\n\n  export type RecommendationType = {\n  displayValue: string;\n  value: number;\n} & { [key: string]: any }\n\n  export type OrderPaymentInstrument = {\n  amount: number;\n  authorizationStatus: Status;\n  bankRoutingNumber: string;\n  maskedGiftCertificateCode: string;\n  paymentBankAccount: PaymentBankAccount;\n  paymentCard: PaymentCard;\n  paymentInstrumentId: string;\n  paymentMethodId: string;\n} & { [key: string]: any }\n\n  export type ProductType = {\n  bundle: boolean;\n  item: boolean;\n  master: boolean;\n  option: boolean;\n  set: boolean;\n  variant: boolean;\n  variationGroup: boolean;\n} & { [key: string]: any }\n\n  export type PaymentBankAccount = {\n  driversLicenseLastDigits?: string;\n  driversLicenseStateCode?: string;\n  holder?: string;\n  maskedDriversLicense?: string;\n  maskedNumber?: string;\n  numberLastDigits?: string;\n} & { [key: string]: any }\n\n  export type Recommendation = {\n  calloutMsg?: string;\n  image?: Image;\n  longDescription?: string;\n  name?: string;\n  recommendationType: RecommendationType;\n  recommendedItemId?: string;\n  recommendedItemLink?: string;\n  shortDescription?: string;\n} & { [key: string]: any }\n\n  export type Variant = {\n  orderable?: boolean;\n  price?: number;\n  productId: string;\n  variationValues?: {\n} & { [key: string]: any }\n;\n} & { [key: string]: any }\n\n  export type BonusDiscountLineItem = {\n  bonusProducts: Array<ProductDetailsLink>;\n  couponCode: string;\n  id: string;\n  maxBonusItems: number;\n  promotionId: string;\n} & { [key: string]: any }\n\n  export type CustomerPaymentInstrument = {\n  bankRoutingNumber?: string;\n  creationDate?: any;\n  lastModified?: any;\n  maskedGiftCertificateCode?: string;\n  paymentBankAccount?: PaymentBankAccount;\n  paymentCard?: PaymentCard;\n  paymentInstrumentId?: string;\n  paymentMethodId?: string;\n} & { [key: string]: any }\n\n  export type Shipment = {\n  adjustedMerchandizeTotalTax?: number;\n  adjustedShippingTotalTax?: number;\n  gift?: boolean;\n  giftMessage?: string;\n  merchandizeTotalTax?: number;\n  productSubTotal?: number;\n  productTotal?: number;\n  shipmentId?: string;\n  shipmentNo?: string;\n  shipmentTotal?: number;\n  shippingAddress?: OrderAddress;\n  shippingMethod?: ShippingMethod;\n  shippingStatus: string;\n  shippingTotal?: number;\n  shippingTotalTax?: number;\n  taxTotal?: number;\n  trackingNumber?: string;\n} & { [key: string]: any }\n\n  export type CustomerInfo = {\n  customerId?: string;\n  customerName?: string;\n  customerNo: string;\n  email: string;\n} & { [key: string]: any }\n\n  export type VariationGroup = {\n  orderable: boolean;\n  price: number;\n  productId: string;\n  variationValues: {\n} & { [key: string]: any }\n;\n} & { [key: string]: any }\n\n  export type SimpleLink = {\n  link: string;\n} & { [key: string]: any }\n\n  export type PaymentBankAccountRequest = {\n  driversLicense: string;\n  driversLicenseStateCode: string;\n  holder: string;\n  number: string;\n} & { [key: string]: any }\n\n  export type PriceAdjustment = {\n  appliedDiscount: Discount;\n  couponCode: string;\n  createdBy: string;\n  creationDate: any;\n  custom: boolean;\n  itemText: string;\n  lastModified: any;\n  manual: boolean;\n  price: number;\n  priceAdjustmentId: string;\n  promotionId: string;\n  promotionLink: string;\n  reasonCode: string;\n} & { [key: string]: any }\n\n  export type PublicProductListItem = {\n  id: string;\n  priority: number;\n  product?: Product;\n  type: string;\n} & { [key: string]: any }\n\n  export type ProductDetailsLink = {\n  productDescription?: string;\n  productId: string;\n  productName?: string;\n  title?: string;\n} & { [key: string]: any }\n\n  export type ProductLink = {\n  sourceProductId: string;\n  sourceProductLink: string;\n  targetProductId: string;\n  targetProductLink: string;\n  type: string;\n} & { [key: string]: any }\n\n  export type OptionItem = {\n  adjustedTax?: number;\n  basePrice?: number;\n  bonusDiscountLineItemId?: string;\n  bonusProductLineItem?: boolean;\n  bundledProductItems?: Array<ProductItem>;\n  gift?: boolean;\n  giftMessage?: string;\n  inventoryId?: string;\n  itemId?: string;\n  itemText?: string;\n  optionId: string;\n  optionItems?: Array<OptionItem>;\n  optionValueId: string;\n  price?: number;\n  priceAdjustments?: Array<PriceAdjustment>;\n  priceAfterItemDiscount?: number;\n  priceAfterOrderDiscount?: number;\n  productId?: string;\n  productListItem?: ProductListItemReference;\n  productName?: string;\n  quantity?: number;\n  shipmentId?: string;\n  shippingItemId?: string;\n  tax?: number;\n  taxBasis?: number;\n  taxClassId?: string;\n  taxRate?: number;\n} & { [key: string]: any }\n\n  export type ShippingMethod = {\n  description?: string;\n  externalShippingMethod?: string;\n  id: string;\n  name?: string;\n  price?: number;\n  shippingPromotions?: Array<ShippingPromotion>;\n} & { [key: string]: any }\n\n  export type ProductListEvent = {\n  city?: string;\n  country?: string;\n  date?: any;\n  state?: string;\n  type: string;\n} & { [key: string]: any }\n\n  export type PasswordChangeRequest = {\n  currentPassword: string;\n  password: string;\n} & { [key: string]: any }\n\n  export type AuthRequest = {\n  type?: string;\n} & { [key: string]: any }\n\n  export type Inventory = {\n  ats?: number;\n  backorderable?: boolean;\n  id: string;\n  inStockDate?: any;\n  orderable?: boolean;\n  preorderable?: boolean;\n  stockLevel?: number;\n} & { [key: string]: any }\n\n  export type CustomerProductList = {\n  coRegistrant?: CustomerProductListRegistrant;\n  creationDate?: any;\n  currentShippingAddressInfo?: CustomerAddressInfo;\n  customerProductListItems?: Array<CustomerProductListItem>;\n  description?: string;\n  event?: ProductListEvent;\n  id?: string;\n  lastModified?: any;\n  name?: string;\n  postEventShippingAddressInfo?: CustomerAddressInfo;\n  productListShippingAddress?: ProductListShippingAddress;\n  public?: boolean;\n  registrant?: CustomerProductListRegistrant;\n  shippingAddressInfo?: CustomerAddressInfo;\n  type?: string;\n} & { [key: string]: any }\n\n  export type Basket = {\n  adjustedMerchandizeTotalTax: number;\n  adjustedShippingTotalTax: number;\n  agentBasket: boolean;\n  basketId: string;\n  billingAddress?: OrderAddress;\n  bonusDiscountLineItems?: Array<BonusDiscountLineItem>;\n  channelType: string;\n  couponItems?: Array<CouponItem>;\n  creationDate: any;\n  currency: string;\n  customerInfo: CustomerInfo;\n  giftCertificateItems?: Array<GiftCertificateItem>;\n  groupedTaxItems?: Array<GroupedTaxItem>;\n  inventoryReservationExpiry?: any;\n  lastModified: any;\n  merchandizeTotalTax: number;\n  notes: SimpleLink;\n  orderPriceAdjustments?: Array<PriceAdjustment>;\n  orderTotal: number;\n  paymentInstruments?: Array<OrderPaymentInstrument>;\n  productItems?: Array<ProductItem>;\n  productSubTotal: number;\n  productTotal: number;\n  shipments: Array<Shipment>;\n  shippingItems: Array<ShippingItem>;\n  shippingTotal: number;\n  shippingTotalTax: number;\n  sourceCode?: string;\n  taxTotal: number;\n  taxation: string;\n  taxRoundedAtGroup?: boolean;\n  temporaryBasket?: boolean;\n} & { [key: string]: any }\n\n  export type CustomerPaymentInstrumentRequest = {\n  bankRoutingNumber?: string;\n  giftCertificateCode?: string;\n  paymentBankAccount?: PaymentBankAccountRequest;\n  paymentCard?: CustomerPaymentCardRequest;\n  paymentMethodId?: string;\n} & { [key: string]: any }\n\n  export type ImageGroup = {\n  images: Array<Image>;\n  variationAttributes?: Array<VariationAttribute>;\n  viewType: string;\n} & { [key: string]: any }\n\n  export type CustomerRegistration = {\n  customer: Customer;\n  password: string;\n} & { [key: string]: any }\n\n  export type Customer = {\n  addresses?: Array<CustomerAddress>;\n  authType?: string;\n  birthday?: any;\n  companyName?: string;\n  creationDate?: any;\n  customerId?: string;\n  customerNo?: string;\n  currentPassword?: string;\n  email?: string;\n  enabled?: boolean;\n  fax?: string;\n  firstName?: string;\n  gender?: number;\n  jobTitle?: string;\n  lastLoginTime?: any;\n  lastModified?: any;\n  lastName?: string;\n  lastVisitTime?: any;\n  login?: string;\n  note?: string;\n  paymentInstruments?: Array<CustomerPaymentInstrument>;\n  phoneBusiness?: string;\n  phoneHome?: string;\n  phoneMobile?: string;\n  preferredLocale?: string;\n  previousLoginTime?: any;\n  previousVisitTime?: any;\n  salutation?: string;\n  secondName?: string;\n  suffix?: string;\n  title?: string;\n} & { [key: string]: any }\n\n  export type PublicProductList = {\n  coRegistrant?: ProductListRegistrant;\n  creationDate?: any;\n  description?: string;\n  event?: ProductListEvent;\n  id: string;\n  lastModified?: any;\n  name?: string;\n  productListItems?: Array<PublicProductListItem>;\n  productListShippingAddress?: ProductListShippingAddress;\n  public: boolean;\n  registrant?: ProductListRegistrant;\n  type: string;\n} & { [key: string]: any }\n\n  export type Option = {\n  description?: string;\n  id: string;\n  image?: string;\n  name?: string;\n  values?: Array<OptionValue>;\n} & { [key: string]: any }\n\n  export type CustomerOrderResult = {\n  limit: number;\n  data: Array<Order>;\n  offset: number;\n  total: number;\n} & { [key: string]: any }\n\n  export type CustomerExtProfileRequest = {\n  authenticationProviderId: string;\n  email?: string;\n  externalId: string;\n  firstName?: string;\n  lastName?: string;\n} & { [key: string]: any }\n\n  export type GiftCertificateItem = {\n  amount: number;\n  giftCertificateItemId?: string;\n  message?: string;\n  recipientEmail: string;\n  recipientName?: string;\n  senderName?: string;\n  shipmentId?: string;\n} & { [key: string]: any }\n\n  export type CustomerExternalProfile = {\n  customerId: string;\n  authenticationProviderId: string;\n  email?: string;\n  externalId: string;\n  firstName?: string;\n  lastName?: string;\n} & { [key: string]: any }\n\n  export type CustomerAddressInfo = {\n  addressId: string;\n  title: string;\n} & { [key: string]: any }\n\n  export type ResetPasswordTokenRequest = {\n  login: string;\n} & { [key: string]: any }\n\n  export type ProductListLink = {\n  description: string;\n  link: string;\n  name: string;\n  public: boolean;\n  title: string;\n  type: string;\n} & { [key: string]: any }\n\n  export type GroupedTaxItem = {\n  taxRate?: number;\n  taxValue?: number;\n}\n  export type ProductListRegistrant = {\n  firstName: string;\n  lastName: string;\n  role: string;\n} & { [key: string]: any }\n\n  export type Order = {\n  adjustedMerchandizeTotalTax?: number;\n  adjustedShippingTotalTax?: number;\n  billingAddress?: OrderAddress;\n  bonusDiscountLineItems?: Array<BonusDiscountLineItem>;\n  channelType?: string;\n  confirmationStatus: string;\n  couponItems?: Array<CouponItem>;\n  createdBy?: string;\n  creationDate?: any;\n  currency?: string;\n  customerInfo?: CustomerInfo;\n  customerName?: string;\n  exportStatus: string;\n  externalOrderStatus?: string;\n  giftCertificateItems?: Array<GiftCertificateItem>;\n  globalPartyId?: string;\n  lastModified?: any;\n  merchandizeTotalTax?: number;\n  notes?: SimpleLink;\n  orderNo?: string;\n  orderPriceAdjustments?: Array<PriceAdjustment>;\n  orderToken?: string;\n  orderTotal?: number;\n  paymentInstruments?: Array<OrderPaymentInstrument>;\n  paymentStatus: string;\n  productItems?: Array<ProductItem>;\n  productSubTotal?: number;\n  productTotal?: number;\n  shipments?: Array<Shipment>;\n  shippingItems?: Array<ShippingItem>;\n  shippingStatus: string;\n  shippingTotal?: number;\n  shippingTotalTax?: number;\n  siteId?: string;\n  sourceCode?: string;\n  status: string;\n  taxTotal?: number;\n  taxation?: string;\n} & { [key: string]: any }\n\n  export type Product = {\n  brand?: string;\n  bundledProducts?: Array<BundledProduct>;\n  currency?: string;\n  ean?: string;\n  fetchDate?: number;\n  id: string;\n  imageGroups?: Array<ImageGroup>;\n  inventories?: Array<Inventory>;\n  inventory?: Inventory;\n  longDescription?: string;\n  manufacturerName?: string;\n  manufacturerSku?: string;\n  master?: Master;\n  minOrderQuantity?: number;\n  name?: string;\n  options?: Array<Option>;\n  pageDescription?: string;\n  pageKeywords?: string;\n  pageTitle?: string;\n  price?: number;\n  priceMax?: number;\n  prices?: {\n} & { [key: string]: any }\n;\n  primaryCategoryId?: string;\n  productLinks?: Array<ProductLink>;\n  productPromotions?: Array<ProductPromotion>;\n  recommendations?: Array<Recommendation>;\n  setProducts?: Array<Product>;\n  shortDescription?: string;\n  stepQuantity?: number;\n  type?: ProductType;\n  unit?: string;\n  upc?: string;\n  validFrom?: any;\n  validTo?: any;\n  variants?: Array<Variant>;\n  variationAttributes?: Array<VariationAttribute>;\n  variationGroups?: Array<VariationGroup>;\n  variationValues?: {\n} & { [key: string]: any }\n;\n} & { [key: string]: any }\n\n  export type Image = {\n  alt?: string;\n  disBaseLink?: string;\n  link: string;\n  title?: string;\n} & { [key: string]: any }\n\n  export type VariationAttributeValue = {\n  description?: string;\n  image?: Image;\n  imageSwatch?: Image;\n  name?: string;\n  orderable?: boolean;\n  value: string;\n} & { [key: string]: any }\n\n  export type ProductPromotion = {\n  calloutMsg: string;\n  promotionId: string;\n  promotionalPrice: number;\n} & { [key: string]: any }\n\n  export type BundledProduct = {\n  id: string;\n  product: Product;\n  quantity: number;\n} & { [key: string]: any }\n\n  export type Status = {\n  code: string;\n  message: string;\n  status: number;\n} & { [key: string]: any }\n\n  export type CustomerProductListItem = {\n  id?: string;\n  priority: number;\n  product?: Product;\n  productId?: string;\n  public: boolean;\n  purchasedQuantity?: number;\n  quantity: number;\n  type?: string;\n} & { [key: string]: any }\n\n  export type ProductListItemReference = {\n  id: string;\n  priority?: number;\n  productList?: ProductListLink;\n  public?: boolean;\n  purchasedQuantity?: number;\n  quantity?: number;\n  type?: string;\n} & { [key: string]: any }\n\n  export type ErrorResponse = {\n  type: string;\n  title?: string;\n  detail?: string;\n  instance?: string;\n} & { [key: string]: any }\n\n  export type ChangeControlled = {\n  creationDate?: any;\n  modificationDate?: any;\n  createdBy?: string;\n  lastModifiedBy?: string;\n} & { [key: string]: any }\n\n  type DateRangeFilter = { [key: string]: any }\ntype EtagResponse = { [key: string]: any }\ntype IntegerRangeFilter = { [key: string]: any }\ntype RateLimited3 = { [key: string]: any }\ntype SyncCreated = { [key: string]: any }\ntype DateConditionalRequest = { [key: string]: any }\ntype RateLimited5 = { [key: string]: any }\ntype EtagConditionalRequest = { [key: string]: any }\ntype AsyncCreated = { [key: string]: any }\ntype RateLimited = { [key: string]: any }\ntype RateLimited2 = { [key: string]: any }\ntype OffsetPaginated = { [key: string]: any }\ntype RangeFilter = { [key: string]: any }\ntype RateLimited4 = { [key: string]: any }\ntype NumericRangeFilter = { [key: string]: any }\ntype DatetimeRangeFilter = { [key: string]: any }\nexport type ChangeControlledDataType = {\n  creationDate?: any;\n  modificationDate?: any;\n  createdBy?: string;\n  lastModifiedBy?: string;\n} & { [key: string]: any }\n\n  export type Error = {\n  type: string;\n  title?: string;\n  detail?: string;\n  instance?: string;\n} & { [key: string]: any }\n\n  type CustomerAuthenticationFailed = { [key: string]: any }\ntype NotFound = { [key: string]: any }\ntype BadRequest = { [key: string]: any }\ntype CustomerExtProfileNotFound = { [key: string]: any }\ntype Unauthorized = { [key: string]: any }\ntype CustomerExtProfileBadRequest = { [key: string]: any }\nexport type Money = {\n  currencyMnemonic?: string;\n  value?: number;\n} & { [key: string]: any }\n\n  export type SimpleSearchResult = {\n  limit: number;\n  hits?: Array<object>;\n  offset: any;\n  total: any;\n} & { [key: string]: any }\n\n  export type SearchRequest = {\n  limit?: number;\n  query: Query;\n  sorts?: Array<Sort>;\n  offset?: any;\n} & { [key: string]: any }\n\n  export type PropertyDefinition = {\n  defaultValue?: PropertyValueDefinition;\n  id?: string;\n  name: L10nString;\n  description: L10nString;\n  key?: boolean;\n  localizable?: boolean;\n  mandatory?: boolean;\n  max?: number;\n  minLength?: number;\n  min?: number;\n  multiValueType?: boolean;\n  regularExpression?: string;\n  scale?: number;\n  searchable?: boolean;\n  siteSpecific?: boolean;\n  system?: boolean;\n  unit?: L10nString;\n  possibleValues?: Array<PropertyValueDefinition>;\n  type: string;\n  visible?: boolean;\n} & { [key: string]: any }\n\n  export type LocalizedString = {\n} & { [key: string]: any }\n\n  export type PaginatedSearchResult = {\n  query: Query;\n  sorts?: Array<Sort>;\n  limit: number;\n  hits?: Array<object>;\n  offset: any;\n  total: any;\n} & { [key: string]: any }\n\n  export type ClosedObject = {\n} & { [key: string]: any }\n\n  export type OpenObject = {\n} & { [key: string]: any }\n\n  type QueryParamsLimit = { [key: string]: any }\ntype QueryParamsOffset = { [key: string]: any }\ntype SiteSpecific = { [key: string]: any }\ntype Selectable = { [key: string]: any }\nexport type NoPropertiesAllowed = {\n}\n  export type SpecifiedPropertiesAllowed = {\n} & { [key: string]: any }\n\n  export type BoolFilter = {\n  filters?: Array<Filter>;\n  operator: string;\n} & { [key: string]: any }\n\n  export type PaginatedSearchResultBase = {\n  query: Query;\n  sorts?: Array<Sort>;\n  limit: number;\n  hits?: Array<object>;\n  offset: any;\n  total: any;\n} & { [key: string]: any }\n\n  export type MatchAllQuery = {\n} & { [key: string]: any }\n\n  export type FilteredQuery = {\n  filter: Filter;\n  query: Query;\n} & { [key: string]: any }\n\n  export type QueryFilter = {\n  query: Query;\n} & { [key: string]: any }\n\n  export type Query = {\n  boolQuery?: BoolQuery;\n  filteredQuery?: FilteredQuery;\n  matchAllQuery?: MatchAllQuery;\n  nestedQuery?: NestedQuery;\n  termQuery?: TermQuery;\n  textQuery?: TextQuery;\n} & { [key: string]: any }\n\n  export type TermQuery = {\n  fields: Array<string>;\n  operator: string;\n  values?: Array<any>;\n} & { [key: string]: any }\n\n  export type TermFilter = {\n  field: string;\n  operator: string;\n  values?: Array<any>;\n} & { [key: string]: any }\n\n  export type TextQuery = {\n  fields: Array<string>;\n  searchPhrase: string;\n} & { [key: string]: any }\n\n  export type Range2Filter = {\n  filterMode?: string;\n  fromField: string;\n  fromInclusive?: boolean;\n  fromValue?: any;\n  toField: string;\n  toInclusive?: boolean;\n  toValue?: any;\n} & { [key: string]: any }\n\n  export type BoolQuery = {\n  must?: Array<Query>;\n  mustNot?: Array<Query>;\n  should?: Array<Query>;\n} & { [key: string]: any }\n\n  export type SimpleSearchResultBase = {\n  limit: number;\n  hits?: Array<object>;\n  offset: any;\n  total: any;\n} & { [key: string]: any }\n\n  export type NestedQuery = {\n  path: string;\n  query: Query;\n  scoreMode?: string;\n} & { [key: string]: any }\n\n  export type Filter = {\n  boolFilter?: BoolFilter;\n  queryFilter?: QueryFilter;\n  range2Filter?: Range2Filter;\n  rangeFilter?: RangeFilter;\n  termFilter?: TermFilter;\n} & { [key: string]: any }\n\n  export type Sort = {\n  field: string;\n  sortOrder?: string;\n} & { [key: string]: any }\n\n  export type SearchRequestBase = {\n  limit?: number;\n  query: Query;\n  sorts?: Array<Sort>;\n  offset?: any;\n} & { [key: string]: any }\n\n  export type MoneyMnemonic = {\n  currencyMnemonic?: string;\n  value?: number;\n} & { [key: string]: any }\n\n  export type L10nString = {\n} & { [key: string]: any }\n\n  export type AttributeDefinition = {\n  defaultValue?: PropertyValueDefinition;\n  id?: string;\n  name: L10nString;\n  description: L10nString;\n  key?: boolean;\n  localizable?: boolean;\n  mandatory?: boolean;\n  max?: number;\n  minLength?: number;\n  min?: number;\n  multiValueType?: boolean;\n  regularExpression?: string;\n  scale?: number;\n  searchable?: boolean;\n  siteSpecific?: boolean;\n  system?: boolean;\n  unit?: L10nString;\n  possibleValues?: Array<PropertyValueDefinition>;\n  type: string;\n  visible?: boolean;\n}\n  export type PropertyValueDefinition = {\n  description: L10nString;\n  displayValue: L10nString;\n  id: string;\n  position?: number;\n  value: string;\n}\n  \n/**\n * All path parameters that are used by at least one ShopperCustomers method.\n */\nexport type ShopperCustomersPathParameters = {\n  organizationId?: string;\n  customerId?: string;\n  addressName?: string;\n  paymentInstrumentId?: string;\n  listId?: string;\n  itemId?: string;\n}\n/**\n * All query parameters that are used by at least one ShopperCustomers method.\n */\nexport type ShopperCustomersQueryParameters = {\n  siteId?: string;\n  externalId?: string;\n  authenticationProviderId?: string;\n  crossSites?: boolean;\n  from?: string;\n  until?: string;\n  status?: string;\n  offset?: any;\n  limit?: number;\n  email?: string;\n  firstName?: string;\n  lastName?: string;\n}\n\n/**\n * All parameters that are used by ShopperCustomers.\n */\nexport type ShopperCustomersParameters = ShopperCustomersPathParameters & BaseUriParameters & ShopperCustomersQueryParameters;\n\n/**\n* [Shopper Customers](https://developer.salesforce.com/docs/commerce/commerce-api/references?meta=shopper-customers:Summary)\n* ==================================\n*\n* *Allow customers to manage their own profiles and product lists.*<br />\n*\n* Simple example:\n*\n* ```typescript\n*   import { ShopperCustomers } from \"commerce-sdk-isomorphic\";\n*\n*   const clientConfig = {\n*     parameters: {\n*       clientId: \"XXXXXX\",\n*       organizationId: \"XXXX\",\n*       shortCode: \"XXX\",\n*       siteId: \"XX\"\n*     }\n*   };\n*   const shopperCustomersClient = new ShopperCustomers(clientConfig);\n* ```\n*\n* <span style=\"font-size:.7em; display:block; text-align: right\">\n* API Version: 0.0.49<br />\n* Last Updated: <br />\n* </span>\n* \n*\n*/\nexport class ShopperCustomers<ConfigParameters extends ShopperCustomersParameters & Record<string, unknown>> {\n  // baseUri is not required on ClientConfig, but we know that we provide one in the class constructor\n  public clientConfig: ClientConfig<ConfigParameters> & { baseUri: string };\n\n  static readonly defaultBaseUri = \"https://{shortCode}.api.commercecloud.salesforce.com/customer/shopper-customers/{version}\";\n\n  static readonly apiPaths = {\n    registerCustomer: \"/organizations/{organizationId}/customers\",\n    resetPassword: \"/organizations/{organizationId}/customers/password/actions/reset\",\n    getResetPasswordToken: \"/organizations/{organizationId}/customers/password/actions/create-reset-token\",\n    registerExternalProfile: \"/organizations/{organizationId}/customers/external-profile\",\n    getExternalProfile: \"/organizations/{organizationId}/customers/external-profile\",\n    getCustomer: \"/organizations/{organizationId}/customers/{customerId}\",\n    updateCustomer: \"/organizations/{organizationId}/customers/{customerId}\",\n    createCustomerAddress: \"/organizations/{organizationId}/customers/{customerId}/addresses\",\n    getCustomerAddress: \"/organizations/{organizationId}/customers/{customerId}/addresses/{addressName}\",\n    removeCustomerAddress: \"/organizations/{organizationId}/customers/{customerId}/addresses/{addressName}\",\n    updateCustomerAddress: \"/organizations/{organizationId}/customers/{customerId}/addresses/{addressName}\",\n    getCustomerBaskets: \"/organizations/{organizationId}/customers/{customerId}/baskets\",\n    getCustomerOrders: \"/organizations/{organizationId}/customers/{customerId}/orders\",\n    updateCustomerPassword: \"/organizations/{organizationId}/customers/{customerId}/password\",\n    createCustomerPaymentInstrument: \"/organizations/{organizationId}/customers/{customerId}/payment-instruments\",\n    deleteCustomerPaymentInstrument: \"/organizations/{organizationId}/customers/{customerId}/payment-instruments/{paymentInstrumentId}\",\n    getCustomerPaymentInstrument: \"/organizations/{organizationId}/customers/{customerId}/payment-instruments/{paymentInstrumentId}\",\n    getCustomerProductLists: \"/organizations/{organizationId}/customers/{customerId}/product-lists\",\n    createCustomerProductList: \"/organizations/{organizationId}/customers/{customerId}/product-lists\",\n    deleteCustomerProductList: \"/organizations/{organizationId}/customers/{customerId}/product-lists/{listId}\",\n    getCustomerProductList: \"/organizations/{organizationId}/customers/{customerId}/product-lists/{listId}\",\n    updateCustomerProductList: \"/organizations/{organizationId}/customers/{customerId}/product-lists/{listId}\",\n    createCustomerProductListItem: \"/organizations/{organizationId}/customers/{customerId}/product-lists/{listId}/items\",\n    deleteCustomerProductListItem: \"/organizations/{organizationId}/customers/{customerId}/product-lists/{listId}/items/{itemId}\",\n    getCustomerProductListItem: \"/organizations/{organizationId}/customers/{customerId}/product-lists/{listId}/items/{itemId}\",\n    updateCustomerProductListItem: \"/organizations/{organizationId}/customers/{customerId}/product-lists/{listId}/items/{itemId}\",\n    getPublicProductListsBySearchTerm: \"/organizations/{organizationId}/product-lists\",\n    getPublicProductList: \"/organizations/{organizationId}/product-lists/{listId}\",\n    getProductListItem: \"/organizations/{organizationId}/product-lists/{listId}/items/{itemId}\",\n  };\n\n  constructor(config: ClientConfigInit<ConfigParameters>) {\n    const cfg = {...config}\n    if (!cfg.baseUri) cfg.baseUri = new.target.defaultBaseUri;\n    // Type assertion is safe because ^^^\n    this.clientConfig = new ClientConfig(cfg) as ClientConfig<ConfigParameters> & { baseUri: string };\n  }\n\n  static readonly paramKeys = {\n    registerCustomer: [\n      'organizationId',\n      'siteId',\n    ],\n    registerCustomerRequired: [\n      'organizationId',\n      'siteId',\n    ],\n    resetPassword: [\n      'organizationId',\n      'siteId',\n    ],\n    resetPasswordRequired: [\n      'organizationId',\n      'siteId',\n    ],\n    getResetPasswordToken: [\n      'organizationId',\n      'siteId',\n    ],\n    getResetPasswordTokenRequired: [\n      'organizationId',\n      'siteId',\n    ],\n    registerExternalProfile: [\n      'organizationId',\n      'siteId',\n    ],\n    registerExternalProfileRequired: [\n      'organizationId',\n      'siteId',\n    ],\n    getExternalProfile: [\n      'organizationId',\n      'externalId',\n      'authenticationProviderId',\n      'siteId',\n    ],\n    getExternalProfileRequired: [\n      'organizationId',\n      'externalId',\n      'authenticationProviderId',\n      'siteId',\n    ],\n    getCustomer: [\n      'organizationId',\n      'customerId',\n      'siteId',\n    ],\n    getCustomerRequired: [\n      'organizationId',\n      'customerId',\n      'siteId',\n    ],\n    updateCustomer: [\n      'organizationId',\n      'customerId',\n      'siteId',\n    ],\n    updateCustomerRequired: [\n      'organizationId',\n      'customerId',\n      'siteId',\n    ],\n    createCustomerAddress: [\n      'organizationId',\n      'customerId',\n      'siteId',\n    ],\n    createCustomerAddressRequired: [\n      'organizationId',\n      'customerId',\n      'siteId',\n    ],\n    getCustomerAddress: [\n      'organizationId',\n      'customerId',\n      'addressName',\n      'siteId',\n    ],\n    getCustomerAddressRequired: [\n      'organizationId',\n      'customerId',\n      'addressName',\n      'siteId',\n    ],\n    removeCustomerAddress: [\n      'organizationId',\n      'customerId',\n      'addressName',\n      'siteId',\n    ],\n    removeCustomerAddressRequired: [\n      'organizationId',\n      'customerId',\n      'addressName',\n      'siteId',\n    ],\n    updateCustomerAddress: [\n      'organizationId',\n      'customerId',\n      'addressName',\n      'siteId',\n    ],\n    updateCustomerAddressRequired: [\n      'organizationId',\n      'customerId',\n      'addressName',\n      'siteId',\n    ],\n    getCustomerBaskets: [\n      'organizationId',\n      'customerId',\n      'siteId',\n    ],\n    getCustomerBasketsRequired: [\n      'organizationId',\n      'customerId',\n      'siteId',\n    ],\n    getCustomerOrders: [\n      'organizationId',\n      'customerId',\n      'crossSites',\n      'from',\n      'until',\n      'status',\n      'siteId',\n      'offset',\n      'limit',\n    ],\n    getCustomerOrdersRequired: [\n      'organizationId',\n      'customerId',\n      'siteId',\n    ],\n    updateCustomerPassword: [\n      'organizationId',\n      'customerId',\n      'siteId',\n    ],\n    updateCustomerPasswordRequired: [\n      'organizationId',\n      'customerId',\n      'siteId',\n    ],\n    createCustomerPaymentInstrument: [\n      'organizationId',\n      'customerId',\n      'siteId',\n    ],\n    createCustomerPaymentInstrumentRequired: [\n      'organizationId',\n      'customerId',\n      'siteId',\n    ],\n    deleteCustomerPaymentInstrument: [\n      'organizationId',\n      'customerId',\n      'paymentInstrumentId',\n      'siteId',\n    ],\n    deleteCustomerPaymentInstrumentRequired: [\n      'organizationId',\n      'customerId',\n      'paymentInstrumentId',\n      'siteId',\n    ],\n    getCustomerPaymentInstrument: [\n      'organizationId',\n      'customerId',\n      'paymentInstrumentId',\n      'siteId',\n    ],\n    getCustomerPaymentInstrumentRequired: [\n      'organizationId',\n      'customerId',\n      'paymentInstrumentId',\n      'siteId',\n    ],\n    getCustomerProductLists: [\n      'organizationId',\n      'customerId',\n      'siteId',\n    ],\n    getCustomerProductListsRequired: [\n      'organizationId',\n      'customerId',\n      'siteId',\n    ],\n    createCustomerProductList: [\n      'organizationId',\n      'customerId',\n      'siteId',\n    ],\n    createCustomerProductListRequired: [\n      'organizationId',\n      'customerId',\n      'siteId',\n    ],\n    deleteCustomerProductList: [\n      'organizationId',\n      'customerId',\n      'listId',\n      'siteId',\n    ],\n    deleteCustomerProductListRequired: [\n      'organizationId',\n      'customerId',\n      'listId',\n      'siteId',\n    ],\n    getCustomerProductList: [\n      'organizationId',\n      'customerId',\n      'listId',\n      'siteId',\n    ],\n    getCustomerProductListRequired: [\n      'organizationId',\n      'customerId',\n      'listId',\n      'siteId',\n    ],\n    updateCustomerProductList: [\n      'organizationId',\n      'customerId',\n      'listId',\n      'siteId',\n    ],\n    updateCustomerProductListRequired: [\n      'organizationId',\n      'customerId',\n      'listId',\n      'siteId',\n    ],\n    createCustomerProductListItem: [\n      'organizationId',\n      'customerId',\n      'listId',\n      'siteId',\n    ],\n    createCustomerProductListItemRequired: [\n      'organizationId',\n      'customerId',\n      'listId',\n      'siteId',\n    ],\n    deleteCustomerProductListItem: [\n      'organizationId',\n      'customerId',\n      'listId',\n      'itemId',\n      'siteId',\n    ],\n    deleteCustomerProductListItemRequired: [\n      'organizationId',\n      'customerId',\n      'listId',\n      'itemId',\n      'siteId',\n    ],\n    getCustomerProductListItem: [\n      'organizationId',\n      'customerId',\n      'listId',\n      'itemId',\n      'siteId',\n    ],\n    getCustomerProductListItemRequired: [\n      'organizationId',\n      'customerId',\n      'listId',\n      'itemId',\n      'siteId',\n    ],\n    updateCustomerProductListItem: [\n      'organizationId',\n      'customerId',\n      'listId',\n      'itemId',\n      'siteId',\n    ],\n    updateCustomerProductListItemRequired: [\n      'organizationId',\n      'customerId',\n      'listId',\n      'itemId',\n      'siteId',\n    ],\n    getPublicProductListsBySearchTerm: [\n      'organizationId',\n      'email',\n      'firstName',\n      'lastName',\n      'siteId',\n    ],\n    getPublicProductListsBySearchTermRequired: [\n      'organizationId',\n      'siteId',\n    ],\n    getPublicProductList: [\n      'organizationId',\n      'listId',\n      'siteId',\n    ],\n    getPublicProductListRequired: [\n      'organizationId',\n      'listId',\n      'siteId',\n    ],\n    getProductListItem: [\n      'organizationId',\n      'listId',\n      'itemId',\n      'siteId',\n    ],\n    getProductListItemRequired: [\n      'organizationId',\n      'listId',\n      'itemId',\n      'siteId',\n    ],\n  } as const;\n  \n      /**\n      * Registers a new customer. The mandatory data are the credentials, profile last name, and email. This requires a JSON Web Token (JWT) which needs to be obtained using the POST /customers/auth API with type \\\"guest\\\", or from the Shopper Login (SLAS) API. The return type object for this endpoint is a common customer object shared by multiple Shopper Customer endpoints. In this case, all customer object details are returned, but attributes that are not included in the response, although they might be part of the customer object, are ignored. For example, although address information is included in the customer object, it is not displayed in the response for this endpoint and is ignored.\n      *\n      * If you would like to get a raw Response object use the other registerCustomer function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type Customer.\n      * \n      */\n      registerCustomer(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerRegistration\n        }>\n      ): Promise<Customer>;\n  \n      /**\n      * Registers a new customer. The mandatory data are the credentials, profile last name, and email. This requires a JSON Web Token (JWT) which needs to be obtained using the POST /customers/auth API with type \\\"guest\\\", or from the Shopper Login (SLAS) API. The return type object for this endpoint is a common customer object shared by multiple Shopper Customer endpoints. In this case, all customer object details are returned, but attributes that are not included in the response, although they might be part of the customer object, are ignored. For example, although address information is included in the customer object, it is not displayed in the response for this endpoint and is ignored.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type Customer otherwise.\n      * \n      */\n      registerCustomer<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerRegistration\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : Customer>;\n  \n      /**\n      * Registers a new customer. The mandatory data are the credentials, profile last name, and email. This requires a JSON Web Token (JWT) which needs to be obtained using the POST /customers/auth API with type \\\"guest\\\", or from the Shopper Login (SLAS) API. The return type object for this endpoint is a common customer object shared by multiple Shopper Customer endpoints. In this case, all customer object details are returned, but attributes that are not included in the response, although they might be part of the customer object, are ignored. For example, although address information is included in the customer object, it is not displayed in the response for this endpoint and is ignored.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type Customer otherwise.\n      * \n      */\n      async registerCustomer(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerRegistration\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | Customer> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for registerCustomer: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/json\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | Customer;\n      }\n  \n      /**\n      * Reset customer password, after obtaining a reset token. This is the second step in the reset customer password flow, where a customer password is reset by providing the new credentials along with a reset token. This call should be preceded by a call to the /create-reset-token endpoint.\n      *\n      * If you would like to get a raw Response object use the other resetPassword function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type void.\n      * \n      */\n      resetPassword(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: ResetPasswordRequest\n        }>\n      ): Promise<void>;\n  \n      /**\n      * Reset customer password, after obtaining a reset token. This is the second step in the reset customer password flow, where a customer password is reset by providing the new credentials along with a reset token. This call should be preceded by a call to the /create-reset-token endpoint.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      resetPassword<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: ResetPasswordRequest\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : void>;\n  \n      /**\n      * Reset customer password, after obtaining a reset token. This is the second step in the reset customer password flow, where a customer password is reset by providing the new credentials along with a reset token. This call should be preceded by a call to the /create-reset-token endpoint.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      async resetPassword(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: ResetPasswordRequest\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | void> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for resetPassword: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/password/actions/reset\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/json\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        if (rawResponse) {\n          return response as Response;\n        }\n      }\n  \n      /**\n      * Get reset password token. This is the first step in the reset customer password flow, where a password reset token is requested for future use to reset a customer password. This call should be followed by a call to the /reset endpoint.\n      *\n      * If you would like to get a raw Response object use the other getResetPasswordToken function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type ResetPasswordToken.\n      * \n      */\n      getResetPasswordToken(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: ResetPasswordTokenRequest\n        }>\n      ): Promise<ResetPasswordToken>;\n  \n      /**\n      * Get reset password token. This is the first step in the reset customer password flow, where a password reset token is requested for future use to reset a customer password. This call should be followed by a call to the /reset endpoint.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type ResetPasswordToken otherwise.\n      * \n      */\n      getResetPasswordToken<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: ResetPasswordTokenRequest\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : ResetPasswordToken>;\n  \n      /**\n      * Get reset password token. This is the first step in the reset customer password flow, where a password reset token is requested for future use to reset a customer password. This call should be followed by a call to the /reset endpoint.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type ResetPasswordToken otherwise.\n      * \n      */\n      async getResetPasswordToken(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: ResetPasswordTokenRequest\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | ResetPasswordToken> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getResetPasswordToken: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/password/actions/create-reset-token\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/json\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | ResetPasswordToken;\n      }\n  \n      /**\n      * Registers a new external profile for a customer. This endpoint accepts a guest customer ShopperToken (JWT) only.\n      *\n      * If you would like to get a raw Response object use the other registerExternalProfile function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type CustomerExternalProfile.\n      * \n      */\n      registerExternalProfile(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerExtProfileRequest\n        }>\n      ): Promise<CustomerExternalProfile>;\n  \n      /**\n      * Registers a new external profile for a customer. This endpoint accepts a guest customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerExternalProfile otherwise.\n      * \n      */\n      registerExternalProfile<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerExtProfileRequest\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : CustomerExternalProfile>;\n  \n      /**\n      * Registers a new external profile for a customer. This endpoint accepts a guest customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerExternalProfile otherwise.\n      * \n      */\n      async registerExternalProfile(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerExtProfileRequest\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | CustomerExternalProfile> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for registerExternalProfile: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/external-profile\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/json\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | CustomerExternalProfile;\n      }\n  \n      /**\n      * Gets the new external profile for a customer. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * If you would like to get a raw Response object use the other getExternalProfile function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param externalId - The External ID of the customer.\n      * @param authenticationProviderId - The authentication Provider Id.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type CustomerExternalProfile.\n      * \n      */\n      getExternalProfile(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            externalId: string\n            authenticationProviderId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<CustomerExternalProfile>;\n  \n      /**\n      * Gets the new external profile for a customer. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param externalId - The External ID of the customer.\n      * @param authenticationProviderId - The authentication Provider Id.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerExternalProfile otherwise.\n      * \n      */\n      getExternalProfile<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            externalId: string\n            authenticationProviderId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : CustomerExternalProfile>;\n  \n      /**\n      * Gets the new external profile for a customer. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param externalId - The External ID of the customer.\n      * @param authenticationProviderId - The authentication Provider Id.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerExternalProfile otherwise.\n      * \n      */\n      async getExternalProfile(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            externalId: string\n            authenticationProviderId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | CustomerExternalProfile> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"externalId\"] !== undefined) {\n          queryParams[\"externalId\"] = optionParams[\"externalId\"];\n        } else if (configParams[\"externalId\"] !== undefined) {\n          queryParams[\"externalId\"] = configParams[\"externalId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: externalId');\n        }\n        if (optionParams[\"authenticationProviderId\"] !== undefined) {\n          queryParams[\"authenticationProviderId\"] = optionParams[\"authenticationProviderId\"];\n        } else if (configParams[\"authenticationProviderId\"] !== undefined) {\n          queryParams[\"authenticationProviderId\"] = configParams[\"authenticationProviderId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: authenticationProviderId');\n        }\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getExternalProfile: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/external-profile\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"GET\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | CustomerExternalProfile;\n      }\n  \n      /**\n      * Gets a customer with all existing addresses and payment instruments associated with the requested customer. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * If you would like to get a raw Response object use the other getCustomer function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type Customer.\n      * \n      */\n      getCustomer(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<Customer>;\n  \n      /**\n      * Gets a customer with all existing addresses and payment instruments associated with the requested customer. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type Customer otherwise.\n      * \n      */\n      getCustomer<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : Customer>;\n  \n      /**\n      * Gets a customer with all existing addresses and payment instruments associated with the requested customer. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type Customer otherwise.\n      * \n      */\n      async getCustomer(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | Customer> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getCustomer: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"GET\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | Customer;\n      }\n  \n      /**\n      * Updates a customer. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * If you would like to get a raw Response object use the other updateCustomer function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type Customer.\n      * \n      */\n      updateCustomer(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: Customer\n        }>\n      ): Promise<Customer>;\n  \n      /**\n      * Updates a customer. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type Customer otherwise.\n      * \n      */\n      updateCustomer<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: Customer\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : Customer>;\n  \n      /**\n      * Updates a customer. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type Customer otherwise.\n      * \n      */\n      async updateCustomer(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: Customer\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | Customer> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for updateCustomer: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/json\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"PATCH\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | Customer;\n      }\n  \n      /**\n      * Creates a new address with the given name for the given customer. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * If you would like to get a raw Response object use the other createCustomerAddress function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type CustomerAddress.\n      * \n      */\n      createCustomerAddress(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerAddress\n        }>\n      ): Promise<CustomerAddress>;\n  \n      /**\n      * Creates a new address with the given name for the given customer. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerAddress otherwise.\n      * \n      */\n      createCustomerAddress<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerAddress\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : CustomerAddress>;\n  \n      /**\n      * Creates a new address with the given name for the given customer. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerAddress otherwise.\n      * \n      */\n      async createCustomerAddress(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerAddress\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | CustomerAddress> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for createCustomerAddress: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}/addresses\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/json\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | CustomerAddress;\n      }\n  \n      /**\n      * Retrieves a customer's address by address name. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * If you would like to get a raw Response object use the other getCustomerAddress function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param addressName - The name of the address to update.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type CustomerAddress.\n      * \n      */\n      getCustomerAddress(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            addressName: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<CustomerAddress>;\n  \n      /**\n      * Retrieves a customer's address by address name. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param addressName - The name of the address to update.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerAddress otherwise.\n      * \n      */\n      getCustomerAddress<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            addressName: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : CustomerAddress>;\n  \n      /**\n      * Retrieves a customer's address by address name. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param addressName - The name of the address to update.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerAddress otherwise.\n      * \n      */\n      async getCustomerAddress(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            addressName: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | CustomerAddress> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n        if (optionParams[\"addressName\"] !== undefined) {\n          pathParams[\"addressName\"] = optionParams[\"addressName\"];\n        } else if (configParams[\"addressName\"] !== undefined) {\n          pathParams[\"addressName\"] = configParams[\"addressName\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: addressName');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getCustomerAddress: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}/addresses/{addressName}\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"GET\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | CustomerAddress;\n      }\n  \n      /**\n      * Deletes a customer's address by address name. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * If you would like to get a raw Response object use the other removeCustomerAddress function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param addressName - The name of the address to update.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type void.\n      * \n      */\n      removeCustomerAddress(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            addressName: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<void>;\n  \n      /**\n      * Deletes a customer's address by address name. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param addressName - The name of the address to update.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      removeCustomerAddress<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            addressName: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : void>;\n  \n      /**\n      * Deletes a customer's address by address name. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param addressName - The name of the address to update.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      async removeCustomerAddress(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            addressName: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | void> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n        if (optionParams[\"addressName\"] !== undefined) {\n          pathParams[\"addressName\"] = optionParams[\"addressName\"];\n        } else if (configParams[\"addressName\"] !== undefined) {\n          pathParams[\"addressName\"] = configParams[\"addressName\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: addressName');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for removeCustomerAddress: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}/addresses/{addressName}\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"DELETE\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        if (rawResponse) {\n          return response as Response;\n        }\n      }\n  \n      /**\n      * Updates a customer's address by address name. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * If you would like to get a raw Response object use the other updateCustomerAddress function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param addressName - The name of the address to update.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type CustomerAddress.\n      * \n      */\n      updateCustomerAddress(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            addressName: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerAddress\n        }>\n      ): Promise<CustomerAddress>;\n  \n      /**\n      * Updates a customer's address by address name. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param addressName - The name of the address to update.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerAddress otherwise.\n      * \n      */\n      updateCustomerAddress<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            addressName: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerAddress\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : CustomerAddress>;\n  \n      /**\n      * Updates a customer's address by address name. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param addressName - The name of the address to update.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerAddress otherwise.\n      * \n      */\n      async updateCustomerAddress(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            addressName: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerAddress\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | CustomerAddress> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n        if (optionParams[\"addressName\"] !== undefined) {\n          pathParams[\"addressName\"] = optionParams[\"addressName\"];\n        } else if (configParams[\"addressName\"] !== undefined) {\n          pathParams[\"addressName\"] = configParams[\"addressName\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: addressName');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for updateCustomerAddress: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}/addresses/{addressName}\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/json\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"PATCH\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | CustomerAddress;\n      }\n  \n      /**\n      * Gets the baskets of a customer. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * If you would like to get a raw Response object use the other getCustomerBaskets function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type BasketsResult.\n      * \n      */\n      getCustomerBaskets(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<BasketsResult>;\n  \n      /**\n      * Gets the baskets of a customer. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type BasketsResult otherwise.\n      * \n      */\n      getCustomerBaskets<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : BasketsResult>;\n  \n      /**\n      * Gets the baskets of a customer. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type BasketsResult otherwise.\n      * \n      */\n      async getCustomerBaskets(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | BasketsResult> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getCustomerBaskets: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}/baskets\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"GET\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | BasketsResult;\n      }\n  \n      /**\n      * Returns a pageable list of all customer's orders. The default page size is 10. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * If you would like to get a raw Response object use the other getCustomerOrders function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param crossSites - The flag indicating whether all sites should be searched. This flag is ignored unless a valid User / Agent is present with a trusted agent on behalf (TAOB) token. Without a TAOB token, only the customer's orders placed on the site specified by siteId are returned.\n      * @param from - \n      * @param until - \n      * @param status - \n      * @param siteId - \n      * @param offset - \n      * @param limit - Maximum records to retrieve per request, not to exceed 50. Defaults to 10.\n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type CustomerOrderResult.\n      * \n      */\n      getCustomerOrders(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            crossSites?: boolean\n            from?: string\n            until?: string\n            status?: string\n            siteId: string\n            offset?: any\n            limit?: number\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<CustomerOrderResult>;\n  \n      /**\n      * Returns a pageable list of all customer's orders. The default page size is 10. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param crossSites - The flag indicating whether all sites should be searched. This flag is ignored unless a valid User / Agent is present with a trusted agent on behalf (TAOB) token. Without a TAOB token, only the customer's orders placed on the site specified by siteId are returned.\n      * @param from - \n      * @param until - \n      * @param status - \n      * @param siteId - \n      * @param offset - \n      * @param limit - Maximum records to retrieve per request, not to exceed 50. Defaults to 10.\n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerOrderResult otherwise.\n      * \n      */\n      getCustomerOrders<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            crossSites?: boolean\n            from?: string\n            until?: string\n            status?: string\n            siteId: string\n            offset?: any\n            limit?: number\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : CustomerOrderResult>;\n  \n      /**\n      * Returns a pageable list of all customer's orders. The default page size is 10. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param crossSites - The flag indicating whether all sites should be searched. This flag is ignored unless a valid User / Agent is present with a trusted agent on behalf (TAOB) token. Without a TAOB token, only the customer's orders placed on the site specified by siteId are returned.\n      * @param from - \n      * @param until - \n      * @param status - \n      * @param siteId - \n      * @param offset - \n      * @param limit - Maximum records to retrieve per request, not to exceed 50. Defaults to 10.\n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerOrderResult otherwise.\n      * \n      */\n      async getCustomerOrders(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            crossSites?: boolean\n            from?: string\n            until?: string\n            status?: string\n            siteId: string\n            offset?: any\n            limit?: number\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | CustomerOrderResult> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"crossSites\"] !== undefined) {\n          queryParams[\"crossSites\"] = optionParams[\"crossSites\"];\n        } else if (configParams[\"crossSites\"] !== undefined) {\n          queryParams[\"crossSites\"] = configParams[\"crossSites\"];\n        }\n        if (optionParams[\"from\"] !== undefined) {\n          queryParams[\"from\"] = optionParams[\"from\"];\n        } else if (configParams[\"from\"] !== undefined) {\n          queryParams[\"from\"] = configParams[\"from\"];\n        }\n        if (optionParams[\"until\"] !== undefined) {\n          queryParams[\"until\"] = optionParams[\"until\"];\n        } else if (configParams[\"until\"] !== undefined) {\n          queryParams[\"until\"] = configParams[\"until\"];\n        }\n        if (optionParams[\"status\"] !== undefined) {\n          queryParams[\"status\"] = optionParams[\"status\"];\n        } else if (configParams[\"status\"] !== undefined) {\n          queryParams[\"status\"] = configParams[\"status\"];\n        }\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n        if (optionParams[\"offset\"] !== undefined) {\n          queryParams[\"offset\"] = optionParams[\"offset\"];\n        } else if (configParams[\"offset\"] !== undefined) {\n          queryParams[\"offset\"] = configParams[\"offset\"];\n        }\n        if (optionParams[\"limit\"] !== undefined) {\n          queryParams[\"limit\"] = optionParams[\"limit\"];\n        } else if (configParams[\"limit\"] !== undefined) {\n          queryParams[\"limit\"] = configParams[\"limit\"];\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getCustomerOrders: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}/orders\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"GET\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | CustomerOrderResult;\n      }\n  \n      /**\n      * Updates the customer's password. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * If you would like to get a raw Response object use the other updateCustomerPassword function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type void.\n      * \n      */\n      updateCustomerPassword(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: PasswordChangeRequest\n        }>\n      ): Promise<void>;\n  \n      /**\n      * Updates the customer's password. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      updateCustomerPassword<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: PasswordChangeRequest\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : void>;\n  \n      /**\n      * Updates the customer's password. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      async updateCustomerPassword(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: PasswordChangeRequest\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | void> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for updateCustomerPassword: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}/password\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/json\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"PUT\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        if (rawResponse) {\n          return response as Response;\n        }\n      }\n  \n      /**\n      * Adds a payment instrument to the customer information. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * If you would like to get a raw Response object use the other createCustomerPaymentInstrument function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type CustomerPaymentInstrument.\n      * \n      */\n      createCustomerPaymentInstrument(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerPaymentInstrumentRequest\n        }>\n      ): Promise<CustomerPaymentInstrument>;\n  \n      /**\n      * Adds a payment instrument to the customer information. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerPaymentInstrument otherwise.\n      * \n      */\n      createCustomerPaymentInstrument<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerPaymentInstrumentRequest\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : CustomerPaymentInstrument>;\n  \n      /**\n      * Adds a payment instrument to the customer information. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerPaymentInstrument otherwise.\n      * \n      */\n      async createCustomerPaymentInstrument(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerPaymentInstrumentRequest\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | CustomerPaymentInstrument> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for createCustomerPaymentInstrument: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}/payment-instruments\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/json\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | CustomerPaymentInstrument;\n      }\n  \n      /**\n      * Deletes a customer's payment instrument. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * If you would like to get a raw Response object use the other deleteCustomerPaymentInstrument function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param paymentInstrumentId - The ID of the payment instrument to be retrievedCustomer.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type void.\n      * \n      */\n      deleteCustomerPaymentInstrument(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            paymentInstrumentId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<void>;\n  \n      /**\n      * Deletes a customer's payment instrument. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param paymentInstrumentId - The ID of the payment instrument to be retrievedCustomer.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      deleteCustomerPaymentInstrument<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            paymentInstrumentId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : void>;\n  \n      /**\n      * Deletes a customer's payment instrument. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param paymentInstrumentId - The ID of the payment instrument to be retrievedCustomer.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      async deleteCustomerPaymentInstrument(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            paymentInstrumentId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | void> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n        if (optionParams[\"paymentInstrumentId\"] !== undefined) {\n          pathParams[\"paymentInstrumentId\"] = optionParams[\"paymentInstrumentId\"];\n        } else if (configParams[\"paymentInstrumentId\"] !== undefined) {\n          pathParams[\"paymentInstrumentId\"] = configParams[\"paymentInstrumentId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: paymentInstrumentId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for deleteCustomerPaymentInstrument: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}/payment-instruments/{paymentInstrumentId}\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"DELETE\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        if (rawResponse) {\n          return response as Response;\n        }\n      }\n  \n      /**\n      * Retrieves a customer's payment instrument by its ID. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * If you would like to get a raw Response object use the other getCustomerPaymentInstrument function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param paymentInstrumentId - The ID of the payment instrument to be retrievedCustomer.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type CustomerPaymentInstrument.\n      * \n      */\n      getCustomerPaymentInstrument(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            paymentInstrumentId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<CustomerPaymentInstrument>;\n  \n      /**\n      * Retrieves a customer's payment instrument by its ID. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param paymentInstrumentId - The ID of the payment instrument to be retrievedCustomer.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerPaymentInstrument otherwise.\n      * \n      */\n      getCustomerPaymentInstrument<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            paymentInstrumentId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : CustomerPaymentInstrument>;\n  \n      /**\n      * Retrieves a customer's payment instrument by its ID. This endpoint accepts a registered customer ShopperToken (JWT) only.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param paymentInstrumentId - The ID of the payment instrument to be retrievedCustomer.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerPaymentInstrument otherwise.\n      * \n      */\n      async getCustomerPaymentInstrument(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            paymentInstrumentId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | CustomerPaymentInstrument> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n        if (optionParams[\"paymentInstrumentId\"] !== undefined) {\n          pathParams[\"paymentInstrumentId\"] = optionParams[\"paymentInstrumentId\"];\n        } else if (configParams[\"paymentInstrumentId\"] !== undefined) {\n          pathParams[\"paymentInstrumentId\"] = configParams[\"paymentInstrumentId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: paymentInstrumentId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getCustomerPaymentInstrument: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}/payment-instruments/{paymentInstrumentId}\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"GET\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | CustomerPaymentInstrument;\n      }\n  \n      /**\n      * Returns all customer product lists. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * If you would like to get a raw Response object use the other getCustomerProductLists function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type CustomerProductListResult.\n      * \n      */\n      getCustomerProductLists(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<CustomerProductListResult>;\n  \n      /**\n      * Returns all customer product lists. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerProductListResult otherwise.\n      * \n      */\n      getCustomerProductLists<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : CustomerProductListResult>;\n  \n      /**\n      * Returns all customer product lists. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerProductListResult otherwise.\n      * \n      */\n      async getCustomerProductLists(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | CustomerProductListResult> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getCustomerProductLists: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}/product-lists\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"GET\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | CustomerProductListResult;\n      }\n  \n      /**\n      * Creates a customer product list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * If you would like to get a raw Response object use the other createCustomerProductList function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type CustomerProductList.\n      * \n      */\n      createCustomerProductList(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerProductList\n        }>\n      ): Promise<CustomerProductList>;\n  \n      /**\n      * Creates a customer product list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerProductList otherwise.\n      * \n      */\n      createCustomerProductList<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerProductList\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : CustomerProductList>;\n  \n      /**\n      * Creates a customer product list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerProductList otherwise.\n      * \n      */\n      async createCustomerProductList(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerProductList\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | CustomerProductList> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for createCustomerProductList: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}/product-lists\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/json\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | CustomerProductList;\n      }\n  \n      /**\n      * Deletes a customer product list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer  ShopperToken.\n      *\n      * If you would like to get a raw Response object use the other deleteCustomerProductList function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type void.\n      * \n      */\n      deleteCustomerProductList(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<void>;\n  \n      /**\n      * Deletes a customer product list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer  ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      deleteCustomerProductList<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : void>;\n  \n      /**\n      * Deletes a customer product list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer  ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      async deleteCustomerProductList(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | void> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n        if (optionParams[\"listId\"] !== undefined) {\n          pathParams[\"listId\"] = optionParams[\"listId\"];\n        } else if (configParams[\"listId\"] !== undefined) {\n          pathParams[\"listId\"] = configParams[\"listId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: listId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for deleteCustomerProductList: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}/product-lists/{listId}\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"DELETE\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        if (rawResponse) {\n          return response as Response;\n        }\n      }\n  \n      /**\n      * Returns a customer product list of the given customer and the items in the list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * If you would like to get a raw Response object use the other getCustomerProductList function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type CustomerProductList.\n      * \n      */\n      getCustomerProductList(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<CustomerProductList>;\n  \n      /**\n      * Returns a customer product list of the given customer and the items in the list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerProductList otherwise.\n      * \n      */\n      getCustomerProductList<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : CustomerProductList>;\n  \n      /**\n      * Returns a customer product list of the given customer and the items in the list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerProductList otherwise.\n      * \n      */\n      async getCustomerProductList(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | CustomerProductList> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n        if (optionParams[\"listId\"] !== undefined) {\n          pathParams[\"listId\"] = optionParams[\"listId\"];\n        } else if (configParams[\"listId\"] !== undefined) {\n          pathParams[\"listId\"] = configParams[\"listId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: listId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getCustomerProductList: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}/product-lists/{listId}\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"GET\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | CustomerProductList;\n      }\n  \n      /**\n      * Changes a product list. Changeable properties are the name, description, and if the list is public. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * If you would like to get a raw Response object use the other updateCustomerProductList function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type CustomerProductList.\n      * \n      */\n      updateCustomerProductList(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerProductList\n        }>\n      ): Promise<CustomerProductList>;\n  \n      /**\n      * Changes a product list. Changeable properties are the name, description, and if the list is public. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerProductList otherwise.\n      * \n      */\n      updateCustomerProductList<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerProductList\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : CustomerProductList>;\n  \n      /**\n      * Changes a product list. Changeable properties are the name, description, and if the list is public. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerProductList otherwise.\n      * \n      */\n      async updateCustomerProductList(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerProductList\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | CustomerProductList> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n        if (optionParams[\"listId\"] !== undefined) {\n          pathParams[\"listId\"] = optionParams[\"listId\"];\n        } else if (configParams[\"listId\"] !== undefined) {\n          pathParams[\"listId\"] = configParams[\"listId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: listId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for updateCustomerProductList: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}/product-lists/{listId}\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/json\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"PATCH\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | CustomerProductList;\n      }\n  \n      /**\n      * Adds an item to the customer's product list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n  \n  Considered values from the request body are:\n  \n  - `type`  The type of the item to be added to the customer's product. Must be a valid type. Mandatory.\n  list.\n  - `priority`  The priority of the item to be added to the customer's product list.\n  - `public`  The flag that determines whether the item to be added to the customer's product list is public.\n  - `product_id`  The ID (SKU) of the product related to the item to be added to the customer's product list. A valid product ID, used for product item type only. Must be a valid product ID; otherwise, a `ProductListProductIdMissingException` or `ProductListProductNotFoundException` is thrown. Mandatory when item type is `product`.\n  - `quantity`  Used for product item type only. This is the quantity of the item to be added to the customer's product list.\n  \n  You can also use a custom property of the form `c_\\<CUSTOM_NAME\\>`. The custom property must correspond to a custom attribute (`\\<CUSTOM_NAME\\>`) that is defined for `ProductListItem`. The value of this property must be valid for the type of custom attribute defined for `ProductListItem`.\n      *\n      * If you would like to get a raw Response object use the other createCustomerProductListItem function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type CustomerProductListItem.\n      * \n      */\n      createCustomerProductListItem(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerProductListItem\n        }>\n      ): Promise<CustomerProductListItem>;\n  \n      /**\n      * Adds an item to the customer's product list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n  \n  Considered values from the request body are:\n  \n  - `type`  The type of the item to be added to the customer's product. Must be a valid type. Mandatory.\n  list.\n  - `priority`  The priority of the item to be added to the customer's product list.\n  - `public`  The flag that determines whether the item to be added to the customer's product list is public.\n  - `product_id`  The ID (SKU) of the product related to the item to be added to the customer's product list. A valid product ID, used for product item type only. Must be a valid product ID; otherwise, a `ProductListProductIdMissingException` or `ProductListProductNotFoundException` is thrown. Mandatory when item type is `product`.\n  - `quantity`  Used for product item type only. This is the quantity of the item to be added to the customer's product list.\n  \n  You can also use a custom property of the form `c_\\<CUSTOM_NAME\\>`. The custom property must correspond to a custom attribute (`\\<CUSTOM_NAME\\>`) that is defined for `ProductListItem`. The value of this property must be valid for the type of custom attribute defined for `ProductListItem`.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerProductListItem otherwise.\n      * \n      */\n      createCustomerProductListItem<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerProductListItem\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : CustomerProductListItem>;\n  \n      /**\n      * Adds an item to the customer's product list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n  \n  Considered values from the request body are:\n  \n  - `type`  The type of the item to be added to the customer's product. Must be a valid type. Mandatory.\n  list.\n  - `priority`  The priority of the item to be added to the customer's product list.\n  - `public`  The flag that determines whether the item to be added to the customer's product list is public.\n  - `product_id`  The ID (SKU) of the product related to the item to be added to the customer's product list. A valid product ID, used for product item type only. Must be a valid product ID; otherwise, a `ProductListProductIdMissingException` or `ProductListProductNotFoundException` is thrown. Mandatory when item type is `product`.\n  - `quantity`  Used for product item type only. This is the quantity of the item to be added to the customer's product list.\n  \n  You can also use a custom property of the form `c_\\<CUSTOM_NAME\\>`. The custom property must correspond to a custom attribute (`\\<CUSTOM_NAME\\>`) that is defined for `ProductListItem`. The value of this property must be valid for the type of custom attribute defined for `ProductListItem`.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerProductListItem otherwise.\n      * \n      */\n      async createCustomerProductListItem(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerProductListItem\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | CustomerProductListItem> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n        if (optionParams[\"listId\"] !== undefined) {\n          pathParams[\"listId\"] = optionParams[\"listId\"];\n        } else if (configParams[\"listId\"] !== undefined) {\n          pathParams[\"listId\"] = configParams[\"listId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: listId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for createCustomerProductListItem: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}/product-lists/{listId}/items\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/json\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"POST\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | CustomerProductListItem;\n      }\n  \n      /**\n      * Removes an item from a customer product list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * If you would like to get a raw Response object use the other deleteCustomerProductListItem function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param itemId - The ID of the product list item to update.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type void.\n      * \n      */\n      deleteCustomerProductListItem(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            itemId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<void>;\n  \n      /**\n      * Removes an item from a customer product list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param itemId - The ID of the product list item to update.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      deleteCustomerProductListItem<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            itemId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : void>;\n  \n      /**\n      * Removes an item from a customer product list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param itemId - The ID of the product list item to update.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type void otherwise.\n      * \n      */\n      async deleteCustomerProductListItem(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            itemId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | void> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n        if (optionParams[\"listId\"] !== undefined) {\n          pathParams[\"listId\"] = optionParams[\"listId\"];\n        } else if (configParams[\"listId\"] !== undefined) {\n          pathParams[\"listId\"] = configParams[\"listId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: listId');\n        }\n        if (optionParams[\"itemId\"] !== undefined) {\n          pathParams[\"itemId\"] = optionParams[\"itemId\"];\n        } else if (configParams[\"itemId\"] !== undefined) {\n          pathParams[\"itemId\"] = configParams[\"itemId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: itemId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for deleteCustomerProductListItem: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}/product-lists/{listId}/items/{itemId}\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"DELETE\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        if (rawResponse) {\n          return response as Response;\n        }\n      }\n  \n      /**\n      * Returns an item of a customer product list and the actual product details like image, availability and price. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * If you would like to get a raw Response object use the other getCustomerProductListItem function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param itemId - The ID of the product list item to update.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type CustomerProductListItem.\n      * \n      */\n      getCustomerProductListItem(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            itemId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<CustomerProductListItem>;\n  \n      /**\n      * Returns an item of a customer product list and the actual product details like image, availability and price. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param itemId - The ID of the product list item to update.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerProductListItem otherwise.\n      * \n      */\n      getCustomerProductListItem<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            itemId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : CustomerProductListItem>;\n  \n      /**\n      * Returns an item of a customer product list and the actual product details like image, availability and price. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param itemId - The ID of the product list item to update.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerProductListItem otherwise.\n      * \n      */\n      async getCustomerProductListItem(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            itemId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | CustomerProductListItem> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n        if (optionParams[\"listId\"] !== undefined) {\n          pathParams[\"listId\"] = optionParams[\"listId\"];\n        } else if (configParams[\"listId\"] !== undefined) {\n          pathParams[\"listId\"] = configParams[\"listId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: listId');\n        }\n        if (optionParams[\"itemId\"] !== undefined) {\n          pathParams[\"itemId\"] = optionParams[\"itemId\"];\n        } else if (configParams[\"itemId\"] !== undefined) {\n          pathParams[\"itemId\"] = configParams[\"itemId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: itemId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getCustomerProductListItem: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}/product-lists/{listId}/items/{itemId}\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"GET\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | CustomerProductListItem;\n      }\n  \n      /**\n      * Updates an item of a customer's product list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n  Considered values from the request body are:\n  \n  priority: This is the priority of the customer's product list item.\n  public: This is the flag whether the customer's product list item is public.\n  quantity: This is the quantity of\n  the customer's product list item. Used for product item type only. \n  custom properties in the form c_\\<CUSTOM_NAME\\>: The custom property\n  must correspond to a custom attribute (\\<CUSTOM_NAME\\>) defined for ProductListItem.\n  The value of this property must be valid for the type of custom attribute defined for ProductListItem.\n      *\n      * If you would like to get a raw Response object use the other updateCustomerProductListItem function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param itemId - The ID of the product list item to update.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      *\n      * @returns A promise of type CustomerProductListItem.\n      * \n      */\n      updateCustomerProductListItem(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            itemId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerProductListItem\n        }>\n      ): Promise<CustomerProductListItem>;\n  \n      /**\n      * Updates an item of a customer's product list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n  Considered values from the request body are:\n  \n  priority: This is the priority of the customer's product list item.\n  public: This is the flag whether the customer's product list item is public.\n  quantity: This is the quantity of\n  the customer's product list item. Used for product item type only. \n  custom properties in the form c_\\<CUSTOM_NAME\\>: The custom property\n  must correspond to a custom attribute (\\<CUSTOM_NAME\\>) defined for ProductListItem.\n  The value of this property must be valid for the type of custom attribute defined for ProductListItem.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param itemId - The ID of the product list item to update.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerProductListItem otherwise.\n      * \n      */\n      updateCustomerProductListItem<T extends boolean>(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            itemId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerProductListItem\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : CustomerProductListItem>;\n  \n      /**\n      * Updates an item of a customer's product list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n  Considered values from the request body are:\n  \n  priority: This is the priority of the customer's product list item.\n  public: This is the flag whether the customer's product list item is public.\n  quantity: This is the quantity of\n  the customer's product list item. Used for product item type only. \n  custom properties in the form c_\\<CUSTOM_NAME\\>: The custom property\n  must correspond to a custom attribute (\\<CUSTOM_NAME\\>) defined for ProductListItem.\n  The value of this property must be valid for the type of custom attribute defined for ProductListItem.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param customerId - The customer ID.\n      * @param listId - The product list ID.\n      * @param itemId - The ID of the product list item to update.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param body - The data to send as the request body.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type CustomerProductListItem otherwise.\n      * \n      */\n      async updateCustomerProductListItem(\n        options: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            customerId: string\n            listId: string\n            itemId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n          body: CustomerProductListItem\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | CustomerProductListItem> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = optionParams[\"customerId\"];\n        } else if (configParams[\"customerId\"] !== undefined) {\n          pathParams[\"customerId\"] = configParams[\"customerId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: customerId');\n        }\n        if (optionParams[\"listId\"] !== undefined) {\n          pathParams[\"listId\"] = optionParams[\"listId\"];\n        } else if (configParams[\"listId\"] !== undefined) {\n          pathParams[\"listId\"] = configParams[\"listId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: listId');\n        }\n        if (optionParams[\"itemId\"] !== undefined) {\n          pathParams[\"itemId\"] = optionParams[\"itemId\"];\n        } else if (configParams[\"itemId\"] !== undefined) {\n          pathParams[\"itemId\"] = configParams[\"itemId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: itemId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for updateCustomerProductListItem: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/customers/{customerId}/product-lists/{listId}/items/{itemId}\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          \"Content-Type\": \"application/json\",\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"PATCH\",\n            headers,\n            body: this.clientConfig.transformRequest(options.body, headers)\n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | CustomerProductListItem;\n      }\n  \n      /**\n      * Retrieves all public product lists as defined by the given search term (for example, email OR first name and last name). This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * If you would like to get a raw Response object use the other getPublicProductListsBySearchTerm function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param email - The email address of the customer the product lists belong to.\n      * @param firstName - The first name of the customer the product lists belong to.\n      * @param lastName - The last name of the customer the product lists belong to.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type PublicProductListResult.\n      * \n      */\n      getPublicProductListsBySearchTerm(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            email?: string\n            firstName?: string\n            lastName?: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<PublicProductListResult>;\n  \n      /**\n      * Retrieves all public product lists as defined by the given search term (for example, email OR first name and last name). This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param email - The email address of the customer the product lists belong to.\n      * @param firstName - The first name of the customer the product lists belong to.\n      * @param lastName - The last name of the customer the product lists belong to.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type PublicProductListResult otherwise.\n      * \n      */\n      getPublicProductListsBySearchTerm<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            email?: string\n            firstName?: string\n            lastName?: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : PublicProductListResult>;\n  \n      /**\n      * Retrieves all public product lists as defined by the given search term (for example, email OR first name and last name). This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param email - The email address of the customer the product lists belong to.\n      * @param firstName - The first name of the customer the product lists belong to.\n      * @param lastName - The last name of the customer the product lists belong to.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type PublicProductListResult otherwise.\n      * \n      */\n      async getPublicProductListsBySearchTerm(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            email?: string\n            firstName?: string\n            lastName?: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | PublicProductListResult> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"email\"] !== undefined) {\n          queryParams[\"email\"] = optionParams[\"email\"];\n        } else if (configParams[\"email\"] !== undefined) {\n          queryParams[\"email\"] = configParams[\"email\"];\n        }\n        if (optionParams[\"firstName\"] !== undefined) {\n          queryParams[\"firstName\"] = optionParams[\"firstName\"];\n        } else if (configParams[\"firstName\"] !== undefined) {\n          queryParams[\"firstName\"] = configParams[\"firstName\"];\n        }\n        if (optionParams[\"lastName\"] !== undefined) {\n          queryParams[\"lastName\"] = optionParams[\"lastName\"];\n        } else if (configParams[\"lastName\"] !== undefined) {\n          queryParams[\"lastName\"] = configParams[\"lastName\"];\n        }\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getPublicProductListsBySearchTerm: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/product-lists\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"GET\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | PublicProductListResult;\n      }\n  \n      /**\n      * Retrieves a public product list by ID and the items under that product list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * If you would like to get a raw Response object use the other getPublicProductList function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param listId - The ID of the list.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type PublicProductList.\n      * \n      */\n      getPublicProductList(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            listId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<PublicProductList>;\n  \n      /**\n      * Retrieves a public product list by ID and the items under that product list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param listId - The ID of the list.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type PublicProductList otherwise.\n      * \n      */\n      getPublicProductList<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            listId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : PublicProductList>;\n  \n      /**\n      * Retrieves a public product list by ID and the items under that product list. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param listId - The ID of the list.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type PublicProductList otherwise.\n      * \n      */\n      async getPublicProductList(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            listId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | PublicProductList> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"listId\"] !== undefined) {\n          pathParams[\"listId\"] = optionParams[\"listId\"];\n        } else if (configParams[\"listId\"] !== undefined) {\n          pathParams[\"listId\"] = configParams[\"listId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: listId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getPublicProductList: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/product-lists/{listId}\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"GET\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | PublicProductList;\n      }\n  \n      /**\n      * Retrieves an item from a public product list and the actual product details like product, image, availability and price. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * If you would like to get a raw Response object use the other getProductListItem function.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param listId - The ID of the list.\n      * @param itemId - The ID of the item.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      *\n      * @returns A promise of type PublicProductListItem.\n      * \n      */\n      getProductListItem(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            listId: string\n            itemId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>\n      ): Promise<PublicProductListItem>;\n  \n      /**\n      * Retrieves an item from a public product list and the actual product details like product, image, availability and price. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param listId - The ID of the list.\n      * @param itemId - The ID of the item.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      * @returns A promise of type Response if rawResponse is true, a promise of type PublicProductListItem otherwise.\n      * \n      */\n      getProductListItem<T extends boolean>(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            listId: string\n            itemId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: T\n      ): Promise<T extends true ? Response : PublicProductListItem>;\n  \n      /**\n      * Retrieves an item from a public product list and the actual product details like product, image, availability and price. This endpoint accepts a registered customer ShopperToken (JWT) or a guest customer ShopperToken.\n      *\n      * @param options - An object containing the options for this method.\n      * @param parameters - An object containing the parameters for this method.\n      * @param organizationId - \n      * @param listId - The ID of the list.\n      * @param itemId - The ID of the item.\n      * @param siteId - \n      * @param headers - An object literal of key value pairs of the headers to be\n      * sent with this request.\n      * @param rawResponse - Set to true to return entire Response object instead of DTO.\n      *\n      * @returns A promise of type Response if rawResponse is true, a promise of type PublicProductListItem otherwise.\n      * \n      */\n      async getProductListItem(\n        options?: RequireParametersUnlessAllAreOptional<{\n          parameters?: CompositeParameters<{\n            organizationId: string\n            listId: string\n            itemId: string\n            siteId: string\n          } & { [key in `c_${string}`]: any }, ConfigParameters>,\n          headers?: { [key: string]: string },\n        }>,\n        rawResponse?: boolean\n      ): Promise<Response | PublicProductListItem> {\n        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>[\"parameters\"]>>);\n        const configParams = this.clientConfig.parameters;\n  \n        const pathParams: ShopperCustomersPathParameters & Required<BaseUriParameters> = {\n          shortCode: configParams.shortCode,\n          version: configParams.version || \"v1\"\n        };\n        if (optionParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = optionParams[\"organizationId\"];\n        } else if (configParams[\"organizationId\"] !== undefined) {\n          pathParams[\"organizationId\"] = configParams[\"organizationId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: organizationId');\n        }\n        if (optionParams[\"listId\"] !== undefined) {\n          pathParams[\"listId\"] = optionParams[\"listId\"];\n        } else if (configParams[\"listId\"] !== undefined) {\n          pathParams[\"listId\"] = configParams[\"listId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: listId');\n        }\n        if (optionParams[\"itemId\"] !== undefined) {\n          pathParams[\"itemId\"] = optionParams[\"itemId\"];\n        } else if (configParams[\"itemId\"] !== undefined) {\n          pathParams[\"itemId\"] = configParams[\"itemId\"];\n        }\n        else {\n          throw new Error('Missing required path parameter: itemId');\n        }\n  \n        const queryParams: ShopperCustomersQueryParameters & { [key in `c_${string}`]: any } = {};\n        if (optionParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = optionParams[\"siteId\"];\n        } else if (configParams[\"siteId\"] !== undefined) {\n          queryParams[\"siteId\"] = configParams[\"siteId\"];\n        }\n        else {\n          throw new Error('Missing required query parameter: siteId');\n        }\n  \n        Object.keys(optionParams).forEach((key) => {\n          if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {\n            queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]\n          } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {\n            console.warn(`Invalid Parameter for getProductListItem: ${key}`)\n          }\n        })\n  \n        const url = new TemplateURL(\n          \"/organizations/{organizationId}/product-lists/{listId}/items/{itemId}\",\n          this.clientConfig.baseUri,\n          {\n            pathParams,\n            queryParams,\n            origin: this.clientConfig.proxy\n          }\n        );\n  \n        const headers: Record<string, string> = {\n          ...this.clientConfig.headers,\n          ...options?.headers\n        };\n  \n        if (!isBrowser) {\n          // Browsers forbid setting a custom user-agent header\n          headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(\" \");\n        }\n  \n        const response = await doFetch(\n          url.toString(),\n          {\n            method: \"GET\",\n            headers,\n            \n          },\n          this.clientConfig,\n          rawResponse\n        )\n  \n        return response as Response | PublicProductListItem;\n      }\n}\n"],"mappings":"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","names":[]}